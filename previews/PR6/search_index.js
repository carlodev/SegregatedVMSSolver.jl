var documenterSearchIndex = {"docs":
[{"location":"mpi/#MPI-Run","page":"MPI run","title":"MPI Run","text":"","category":"section"},{"location":"mpi/","page":"MPI run","title":"MPI run","text":"The code can be run in Message Passing Interface (MPI).  The code is made in such a way that it can run:","category":"page"},{"location":"mpi/","page":"MPI run","title":"MPI run","text":"in the REPL, selecting :backend => with_debug()\nin MPI, selecting :backend => with_mpi()","category":"page"},{"location":"mpi/","page":"MPI run","title":"MPI run","text":"When running in MPI the code cannot be easily executed in the REPL. Instead, one has to run them from a terminal using the mpiexecjl script as provided by MPI.jl. ","category":"page"},{"location":"mpi/","page":"MPI run","title":"MPI run","text":"For example with the command: ","category":"page"},{"location":"mpi/","page":"MPI run","title":"MPI run","text":"mpiexecjl -n 4 julia --project=. run_simulation.jl","category":"page"},{"location":"mpi/","page":"MPI run","title":"MPI run","text":"It is possible to launch the tests changing the backend.","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"Cases/liddriven/#Lid-Driven-Cavity-Flow","page":"Lid Driven Cavity Flow","title":"Lid Driven Cavity Flow","text":"","category":"section"},{"location":"Cases/liddriven/","page":"Lid Driven Cavity Flow","title":"Lid Driven Cavity Flow","text":"The Lid Driven Cavity flow is another standard case. It is a box of 1x1 dimension with the top side that can slide. The user can set different Reynolds.","category":"page"},{"location":"Cases/taylorgreen/#Taylor-Green-Vortex","page":"Taylor Green","title":"Taylor Green Vortex","text":"","category":"section"},{"location":"Cases/taylorgreen/","page":"Taylor Green","title":"Taylor Green","text":"It solves the 2D Taylor Green Vortex case. It is the only case where analtical solution are available:","category":"page"},{"location":"Cases/taylorgreen/","page":"Taylor Green","title":"Taylor Green","text":"u_x= U_a-V_s cos bigg (fracpiD(x-U_a t)bigg ) sin bigg (fracpiD(y-V_a t)bigg ) e^-frac2 v pi^2D^2 t","category":"page"},{"location":"Cases/taylorgreen/","page":"Taylor Green","title":"Taylor Green","text":"u_y= V_a+V_s sin bigg (fracpiD(x-U_a t)bigg ) cos bigg (fracpiD(y-V_a t)bigg ) e^-frac2 nu pi^2D^2 t","category":"page"},{"location":"Cases/taylorgreen/","page":"Taylor Green","title":"Taylor Green","text":"p=-fracV_s^24bigg ((cos(2 fracpiD(x-U_a t) )+cos (2 fracpiD(y-V_a t))bigg ) e^-frac4 v pi^2D^2 t","category":"page"},{"location":"Cases/taylorgreen/","page":"Taylor Green","title":"Taylor Green","text":"omega=frac2 V_s piD cos bigg (fracpiD(x-U_a t)bigg ) cos bigg (fracpiD(y-V_a t)bigg ) e^-frac4 nu pi^2D^2 t","category":"page"},{"location":"Cases/taylorgreen/","page":"Taylor Green","title":"Taylor Green","text":"Because of an analytical solution it is used as a benchamark case for verifing mesh convergence, CFL stability and processor scalability. The domain is a squqare of 2Dx2D with periodic boundaries over the 4 sides. The initial solution is retrived from the analytical solution. The pressure is fixed in the centre of the domain equal to the analytical solution.  The parameters set by the user are overwritten by the following standard values:","category":"page"},{"location":"Cases/taylorgreen/","page":"Taylor Green","title":"Taylor Green","text":"Vs = 1ms swirling velocity\nUa = 02ms translational velocity in x direction\nVa = 03ms translational  velocity in y direction\nD = 05m vortex dimensions\nnu = 0001 m^2s","category":"page"},{"location":"run/#Package-usage","page":"Running Simulation","title":"Package usage","text":"","category":"section"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":"The package allows the user to set a wide variety of options. Problem Settings:","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":":N = number of divisions for each dimension.\n:D = dimension. It can be 2 or 3.\n:order = order of the elements. At the moment just the order 1 is tested.\n:case it can be \"TaylorGreen\", \"LidDriven\", \"Cylinder\", \"Channel\", \"Airfoil\".\n:u_in the inlet velocity for \"Airfoil\" and \"Cylinder\", or the lid velocity for \"LidDriven\n:c chord length in the \"Airfoil\" case, or dimension of lid for \"LidDriven\". It is used to compute the viscosity :ν from the Reynolds and velocity\n:Re Reynolds number. \n:ν kinematic viscosity. It can be overwritten in order to satisfy the Reynolds, in this case a warning informs the user.\n:ρ density. It used just to compute the force. The advice is to keep it 1.0 and just set the Reynolds.","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":"Time settings","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":":t0 starting time.\n:dt time step length.\n:tF end time.\n:t_endramp for high reynolds cases, like airfoils and lid driven, for improving numeric stability the inlet velocity (or the lid velocity) are increased from 0 up the desired value in the time between :t0 and :tendramp. If :t0 = :tendramp there is no ramping.","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":"Ode Settings","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":"θ parameter required for time integration.  θ = 05 allows to have 2nd order accuracy on velocity. For the pressure is alwys used a fully implicit method.","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":"Numeric Settings","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":":method can be :SUPG or :VMS\n:Cᵢ is a vector containing stabilization coefficients used for the :VMS. The suggested values are [4,36], [3]\n:options the settings for the petsc solver. The function petsc_options can be used.","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":"Print Settings","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":":printmodel can be true or false. If true mesh is saved as a .pvtu file.\n:printinitial can be true or false. If true saves the flowfield at t0. It is useful when restarting from a previous solution.\n:benchmark  can be true or false. If true it does not print the solution, and it gives the time needed for computing the iteration form the 2nd till the end. The first iteration is not taken into account for computing the time because of precompilation.\n:name_tags specify the boundary names to export, eg: :name_tags=>[\"airfoil\",\"inlet\"]\n:fieldexport specify which field to export for each boundary specified in name_tags. eg: [(\"ph\",\"friction\")] The supported field are\nph pressure\nfriction for friction (not taking into account the viscosity)\nuh for velocity (x,y,z components)","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":"Mesh Settings","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":":mesh_file is a string with the name of the .msh that can be read.","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":"Partitioning Settings","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":":rank_partition tuple which set the number of division on each axes to split the geometry to the processors.  For non cartesian problems it does not matter how the cores are split into the dimensions as long as prod(rank_partition) is equal to the MPI ranks.\nbackend can be with_debug() (can be run in the REPL) or with_mpi(). ","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":"Restart Settings","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":":restart can be true or false. If false the initial conditions are computed internally using :u_in or analytical solution (\"TaylorGreen\"). \n:restart_file is used only if :restartis true. It is a .csv file created from ParaView using the SpreadSheet. It has the list of fo velocity and pressure in each node. It is better to run clean grid in Paraview before for get rid of duplicate points.","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":"Monitor Settings","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":":log_dir select the folder path where the simulation while running check if there is the file PrintSim.txt. If the file exists the simulation will start creating .pvtu files at the end of every time step. The contenent of the file does not matter. By default the directory is /Log","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":"using SegregatedVMSSolver\nusing Parameters,PartitionedArrays\n\n  \n   params = Dict(\n         :N => 32,\n         :D => 2, #Dimension\n         :order => 1, \n         :t0 => 0.0,\n         :dt => 0.25,\n         :tF => 1.0,\n         :case => \"TaylorGreen\",\n         :θ => 0.5,\n         :u_in=> 1.0,\n        \n         :backend => with_debug,  #or with_mpi()\n         :rank_partition=>(2,2),\n         :ν => 0.001,\n         :petsc_options => petsc_options_default(),\n         :method=>:VMS,\n         :Cᵢ => [4, 36],\n    \n         :t_endramp=>0.0,\n         :mesh_file => \" \",\n         :Re=> 1000,\n         \n         :c=> 1.0,\n \n   )\n   \n   \n SegregatedVMSSolver.main(params) \n","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":"The example above run in the REPL emulating a parallel run over 4 processors (you can see it by the options rank_partition). ","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":"info: numeric info\nChanging the backend to with_mpi() allows it to run in MPI. with_debug is useful to debug the code.","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":"info: numeric info\nCreating Log/PrintSim.txt allows to monitor the current state of the simulation. ","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":"info: Experimental feature\nIt is possible to specify some x coordinates to export just planes at that coordinate, it is useful for hardcore validation of airfoils. :newtag => Dict(:range_coordinate=>[0.60 , 0.65, 0.70, 0.75, 0.80], :tagname => [\"V60\", \"V65\", \"V70\", \"V75\", \"V80\"]),","category":"page"},{"location":"post_proc/#Post-Processing","page":"Post Processing","title":"Post Processing","text":"","category":"section"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"In this section is explained how to visualize the results and use the integrated post processing api for studying airfoils. All the results are saved in the folder /Results. ","category":"page"},{"location":"post_proc/#Using-Paraview","page":"Post Processing","title":"Using Paraview","text":"","category":"section"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"ParaView which allows to graphically visualize the results and open .vtu and .pvtu files. There are a lot of embedded and avanced tools.","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"info: numeric info\nCreating Log/PrintSim.txt allows to monitor the current state of the simulation creating .pvtu files.","category":"page"},{"location":"post_proc/#Using-Integrated-API","page":"Post Processing","title":"Using Integrated API","text":"","category":"section"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"A specific module ReadAirfoilResults has been develop. While running an Airfoil simulation the code automatically saves the results - for pressure and velocity normal gradient - just for the nodes that are part of the airfoil boundary. ","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"Use the ReadAirfoilResults module","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"using SegregatedVMSSolver\nusing SegregatedVMSSolver.ReadAirfoilResults","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"Specify the path where the .csv file with the results are stored. Get the nodes, normals.","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"res_path = \"Results/\"\nnodes = get_nodes(res_path)\nnormals = get_normals(res_path)","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"You can get the everage - in time and spanwise direction - of velocity and friction field. It is possible to specify the number of time-step that you want to skip at the beginning of the averaging using the keyword offset. It allows to avoid averaging also the initils time-steps where the solution is still evolving.","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"Ph = average_field(res_path, \"ph\", nodes)\nFriction = average_field(res_path, \"friction\", nodes)\n\n","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"Writing the parameters of the simulation allows the code to get the local values for fricition and pressure and to distiguish between top and bottom side. ","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"Re = 500_000\nu0 = 1.0\nc = 1.0\nrho = 1.0\nμ = u0*c*rho/Re\nα = 1.0\n\ntop_nodesx,bottom_nodesx,top_nodesy,bottom_nodesy,cp_top,cp_bottom,\nfriction_top,friction_bottom,n_Γ_airfoil_top,n_Γ_airfoil_bottom=extract_airfoil_features(nodes, normals, Ph, Friction; u0=u0, μ=μ, rho=rho, α=α, chord=c)\n\nCL,CD = compute_CL_CD(top_nodesx,bottom_nodesx,top_nodesy,bottom_nodesy,cp_top,cp_bottom,\nfriction_top,friction_bottom; chord = c)","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"It is possible to plot the results. For example","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"using Plots\n\nplot(top_nodesx, friction_top, label = \"VMS\", color = :red, linewidth = 1.5)\nplot!(bottom_nodesx,friction_bottom, label = false, color = :red, linewidth = 1.5 )\n","category":"page"},{"location":"api_info/#Index","page":"API information","title":"Index","text":"","category":"section"},{"location":"api_info/#Initialize-Parameters","page":"API information","title":"Initialize Parameters","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"init_params\nverifykey","category":"page"},{"location":"api_info/#SegregatedVMSSolver.init_params","page":"API information","title":"SegregatedVMSSolver.init_params","text":"init_params(params::Dict{Symbol,Any})\n\nIt initialize the parametes of the simulations. Default values are added if not specified by the user. In case of a restarting simulation it reads the file and create a initial_rescale_factor<1 for CFL ramping initialization.\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.verifykey","page":"API information","title":"SegregatedVMSSolver.verifykey","text":"verifykey(params::Dict{Symbol,Any},keyname; val = false)\n\nIt check if the dictionary params has the entry keyname. If not it adds the new entry with the value val. It is used to add default values\n\n\n\n\n\n","category":"function"},{"location":"api_info/#Commons-Procedures","page":"API information","title":"Commons Procedures","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"print_model\ncreation_fe_spaces\ncreate_initial_conditions\ncreate_PETSc_setup\nsolve_case","category":"page"},{"location":"api_info/#SegregatedVMSSolver.print_model","page":"API information","title":"SegregatedVMSSolver.print_model","text":"print_model(params::Dict{Symbol, Any})\n\nIt prints the model mesh\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.creation_fe_spaces","page":"API information","title":"SegregatedVMSSolver.creation_fe_spaces","text":"creationfespaces(params::Dict{Symbol,Any}, udiritags, udirivalues, pdiritags, pdirivalues)\n\nIt creates the finite elements spaces accordingly to the previously generated dirichelet tags\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.create_initial_conditions","page":"API information","title":"SegregatedVMSSolver.create_initial_conditions","text":"createinitialconditions(params::Dict{Symbol,Any})\n\nIt creates the initial conditions for velocity and pressure. If restart is true then the velocity and the pressure field are interpoled on the specified DataFrame.  \n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.create_PETSc_setup","page":"API information","title":"SegregatedVMSSolver.create_PETSc_setup","text":"createPETScsetup(M::AbstractMatrix,ksp_setup::Function)\n\nWrapper for creating PETSc symbolic and numeric setup for GridapPETSc  \n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.solve_case","page":"API information","title":"SegregatedVMSSolver.solve_case","text":"solve_case(params::Dict{Symbol,Any})\n\nIt solves iteratively the velocity and pressure system.\n\n\n\n\n\n","category":"function"},{"location":"api_info/#AddNewTags","page":"API information","title":"AddNewTags","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"create_new_tag!\nadd_new_tag!\nadd_centre_tag!","category":"page"},{"location":"api_info/#SegregatedVMSSolver.create_new_tag!","page":"API information","title":"SegregatedVMSSolver.create_new_tag!","text":"create_new_tag!(model::GridapDistributed.DistributedDiscreteModel, tagname::String, is_tag::Function)\n\nIt creates the centre tag at the tag_coordinate (Point); if mesh extremely fine the tolrances have to be smaller (unlikely)\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.add_new_tag!","page":"API information","title":"SegregatedVMSSolver.add_new_tag!","text":"add_new_tag!(model, tag_coordinate::Point, tagname::String)\n\nIt add a new tag named tagname at the specified tag_coordinates    \n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.add_centre_tag!","page":"API information","title":"SegregatedVMSSolver.add_centre_tag!","text":"add_centre_tag!(model, tag_coordinate::Point)\n\nIt creates the centre tag at the tag_coordinate (Point); if mesh extremely fine the tolrances have to be smaller (unlikely)\n\n\n\n\n\n","category":"function"},{"location":"api_info/#Stabilization-Parameters","page":"API information","title":"Stabilization Parameters","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"h_param\nG_params\ncompute_d\ncompute_G\ncompute_GG\ncompute_gg","category":"page"},{"location":"api_info/#SegregatedVMSSolver.h_param","page":"API information","title":"SegregatedVMSSolver.h_param","text":"h_param(Ω::Triangulation, D::Int64)\n\nFor a given triangulation Ω it computes the cell size Area^12 D=2 Volume^13 D=3\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.G_params","page":"API information","title":"SegregatedVMSSolver.G_params","text":"G_params(Ω::Triangulation, params)\n\nCompute the tensor G and the values GG and gg according to the VMS formulation proposed by [5] \n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.compute_d","page":"API information","title":"SegregatedVMSSolver.compute_d","text":"compute_d(trian::Gridap.Geometry.BodyFittedTriangulation, params) #trian == Ω\n\nThe inverse of the cell-map-field. It is evaluted in the middle of the refernce domain.\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.compute_G","page":"API information","title":"SegregatedVMSSolver.compute_G","text":"compute_G(trian::Gridap.Geometry.BodyFittedTriangulation, params)\n\nCompute G (AbstractArray of TensorValues)\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.compute_GG","page":"API information","title":"SegregatedVMSSolver.compute_GG","text":"compute_GG(trian::Gridap.Geometry.BodyFittedTriangulation, params)\n\nCompute GG \n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.compute_gg","page":"API information","title":"SegregatedVMSSolver.compute_gg","text":"compute_GG(trian::Gridap.Geometry.BodyFittedTriangulation, params)\n\nCompute gg \n\n\n\n\n\n","category":"function"},{"location":"api_info/#Linear-Utilities","page":"API information","title":"Linear Utilities","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"create_ũ_vector\nupdate_ũ_vector!\nupdate_ũ","category":"page"},{"location":"api_info/#SegregatedVMSSolver.create_ũ_vector","page":"API information","title":"SegregatedVMSSolver.create_ũ_vector","text":"createũvector(zfv1::AbstractVector)\n\nIt allocates the vector to keep in memory the velocity field up to previous 4 time steps\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.update_ũ_vector!","page":"API information","title":"SegregatedVMSSolver.update_ũ_vector!","text":"updateũvector!(ũvec::Vector, uhnew::AbstractVector)\n\nIt updates the vector which stores the values of velocity at previous time steps.\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.update_ũ","page":"API information","title":"SegregatedVMSSolver.update_ũ","text":"updateũ(ũvec::Vector)\n\nIt uses the Taylor expansion proposed by [6]\n\n\n\n\n\n","category":"function"},{"location":"api_info/#Stabilized-Equations","page":"API information","title":"Stabilized Equations","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"cconv\nsegregated_equations_SUPG!\nsegregated_equations_VMS!","category":"page"},{"location":"api_info/#SegregatedVMSSolver.cconv","page":"API information","title":"SegregatedVMSSolver.cconv","text":"cconv(uadv, ∇u) \n\nWrapper for the convective term   u(nabla u)  \n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.segregated_equations_SUPG!","page":"API information","title":"SegregatedVMSSolver.segregated_equations_SUPG!","text":"segregatedequationsSUPG!(u_adv, params)\n\nIt provides the SUPG segregated and linearized equations following the model proposed by [2]\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.segregated_equations_VMS!","page":"API information","title":"SegregatedVMSSolver.segregated_equations_VMS!","text":"segregatedequationsSUPG!(u_adv, params)\n\nIt provides the VMS segregated and linearized equations \n\n\n\n\n\n","category":"function"},{"location":"api_info/#SolversOptions","page":"API information","title":"SolversOptions","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"petsc_options","category":"page"},{"location":"api_info/#SegregatedVMSSolver.petsc_options","page":"API information","title":"SegregatedVMSSolver.petsc_options","text":"petscoptions(; velksp=\"gmres\", velpc=\"gamg\", presksp = \"cg\", pres_pc = \"gamg\") It provides the command-line for GridapPETSc to solve the segregated linear systems\n\n\n\n\n\n","category":"function"},{"location":"api_info/#MatrixCreation","page":"API information","title":"MatrixCreation","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"allocate_Mat_inv_ML\ninv_lump_vel_mass!\ninitialize_vectors\nmatrices_and_vectors ","category":"page"},{"location":"api_info/#SegregatedVMSSolver.allocate_Mat_inv_ML","page":"API information","title":"SegregatedVMSSolver.allocate_Mat_inv_ML","text":"allocateMatinvML(MatML::PSparseMatrix) \n\nIt allocates a zero vector where to store the inverse of the lumped matrix\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.inv_lump_vel_mass!","page":"API information","title":"SegregatedVMSSolver.inv_lump_vel_mass!","text":"invlumpvelmass!(MatinvML::PVector,MatML::PSparseMatrix)\n\nIt computes the lumped matrix, takes the inverse of the diagonal elements.\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.initialize_vectors","page":"API information","title":"SegregatedVMSSolver.initialize_vectors","text":"initialize_vectors(matrices::Tuple,uh0,ph0)\n\nIt initializes vectors where velocity, pressure, acceleration and all the increments will be stored.\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.matrices_and_vectors","page":"API information","title":"SegregatedVMSSolver.matrices_and_vectors","text":"matricesandvectors(trials, tests, t::Real, u_adv, params; method=:VMS)\n\nIt updates matrices and vectors\n\n\n\n\n\n","category":"function"},{"location":"api_info/#Restart","page":"API information","title":"Restart","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"find_idx\nuh_restart\nph_restart\nrestart_uh_field\nrestart_ph_field","category":"page"},{"location":"api_info/#SegregatedVMSSolver.find_idx","page":"API information","title":"SegregatedVMSSolver.find_idx","text":"find_idx(p::VectorValue{3, Float64}, params)\n\nFor a given point p it search on the restart_file provided by the user the closer node and provides the index of such node.\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.uh_restart","page":"API information","title":"SegregatedVMSSolver.uh_restart","text":"uh_restart(p, params::Dict{Symbol, Any})\n\nFor a given point p it calles find_idx which provide the line of the csv file corresponding to that point. Then, it calles uh which provide the VectorValue of the velocity at that point.\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.ph_restart","page":"API information","title":"SegregatedVMSSolver.ph_restart","text":"ph_restart(p, params::Dict{Symbol, Any})\n\nFor a given point p it calles find_idx which provide the line of the csv file corresponding to that point. Then, it calles ph which provide the scalar pressure value at that point.\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.restart_uh_field","page":"API information","title":"SegregatedVMSSolver.restart_uh_field","text":"restart_uh_field(params::Dict{Symbol, Any})\n\nIt provides a suitable function which gives for each point the specified velocity in restart_file. It is used as initial condition for restarting a simulation at a specific time step.\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.restart_ph_field","page":"API information","title":"SegregatedVMSSolver.restart_ph_field","text":"restart_ph_field(params::Dict{Symbol, Any})\n\nIt provides a suitable function which gives for each point the specified pressure in restart_file. It is used as initial condition for restarting a simulation at a specific time step.\n\n\n\n\n\n","category":"function"},{"location":"api_info/","page":"API information","title":"API information","text":"CurrentModule = SegregatedVMSSolver.ExportUtility","category":"page"},{"location":"api_info/#SegregatedVMSSolver.ExportUtility","page":"API information","title":"SegregatedVMSSolver.ExportUtility","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"Modules = [ ExportUtility,]","category":"page"},{"location":"api_info/#SegregatedVMSSolver.ExportUtility.conv_to_df-Tuple{Vector{Float64}}","page":"API information","title":"SegregatedVMSSolver.ExportUtility.conv_to_df","text":"conv_to_df(vv::Vector)\n\nConvert a Vector{Float64} to a DataFrame. It is used for export pressure field.\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ExportUtility.conv_to_df-Tuple{Vector}","page":"API information","title":"SegregatedVMSSolver.ExportUtility.conv_to_df","text":"conv_to_df(vv::Vector)\n\nConvert a Vector{Vector} to a DataFrame. It is used for export nodes, normals.\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ExportUtility.create_export_tags!-Tuple{Dict{Symbol, Any}}","page":"API information","title":"SegregatedVMSSolver.ExportUtility.create_export_tags!","text":"create_export_tags!(params::Dict{Symbol,Any})\n\nFor each ´nametags´ it creates the ´exporttags´ dictionary\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ExportUtility.export_fields-Tuple{Dict{Symbol, Any}, Float64, Any, Any}","page":"API information","title":"SegregatedVMSSolver.ExportUtility.export_fields","text":"export_fields(params::Dict{Symbol,Any}, local_unique_idx, global_unique_idx, tt::Float64, uh0, ph0)\n\nExport pressure and friction (not multiplied by viscosity) - airfoil simulations oriented\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ExportUtility.print_on_request-Tuple{String}","page":"API information","title":"SegregatedVMSSolver.ExportUtility.print_on_request","text":"print_on_request(log_dir::String)\n\nIf in the directory log_dir exists and there is the PrintSim.txt file return true. If true is printing simulations results in Paraview format (.vtu and .pvtu). \n\n\n\n\n\n","category":"method"},{"location":"api_info/","page":"API information","title":"API information","text":"CurrentModule = SegregatedVMSSolver.ReadAirfoilResults","category":"page"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"Modules = [ ReadAirfoilResults,]","category":"page"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.average_field-Tuple{String, String, DataFrames.DataFrame}","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.average_field","text":"average_field(path::String, field_name::String, nodes::DataFrame; offset=1, offend_ = 0)\n\nIt computes the time-average and also the spanwise averge (z direction). field_name can be ph for pressure or friction for friction. It is possible to skip a certain amount of initial time-step when averaging setting the offset.\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.compute_CL_CD-NTuple{8, Any}","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.compute_CL_CD","text":"compute_CL_CD(top_nodesx,bottom_nodesx,top_nodesy,bottom_nodesy,cp_top,cp_bottom,\nfriction_top,friction_bottom; chord = 1.0)\n\nIt computes lift and drag coefficients\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.extract_airfoil_features-NTuple{4, DataFrames.DataFrame}","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.extract_airfoil_features","text":"extract_airfoil_features(nodes::DataFrame, n_Γ0::DataFrame, Ph::DataFrame, Friction::DataFrame; u0::Float64, μ::Float64, rho::Float64, α::Float64, chord::Float64)\n\nIt provides the airfoil features like pressure and friction coefficient splitted between top and bottom. The nodes and results are orderded for growing x coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.get_nodes-Tuple{String}","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.get_nodes","text":"get_nodes(path::String)\n\nIt provides a DataFrame with the nodes of the Airfoil boundary\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.get_normals-Tuple{String}","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.get_normals","text":"get_nodes(path::String)\n\nIt provides a DataFrame with the normals vectors at the surface of the Airfoil boundary    \n\n\n\n\n\n","category":"method"},{"location":"api_info/","page":"API information","title":"API information","text":"CurrentModule = SegregatedVMSSolver.WallDistance","category":"page"},{"location":"api_info/#SegregatedVMSSolver.WallDistance","page":"API information","title":"SegregatedVMSSolver.WallDistance","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"Modules = [ WallDistance,]","category":"page"},{"location":"api_info/#SegregatedVMSSolver.WallDistance.get_initial_conditions-Tuple{String, Int64, Float64, Real, Float64, Any}","page":"API information","title":"SegregatedVMSSolver.WallDistance.get_initial_conditions","text":"get_initial_conditions(mesh_file::String, D::Int64, u_in::Float64, Re::Real, chord::Float64, walltag)\n\nIt creates the .vtu file with the boundary layer initialization and also the .csv file which can be used to start a simulation over an airfoil. It return a dataframe where for each nodes are provided the coordinates and the velocity vector components.\n\n\n\n\n\n","category":"method"},{"location":"blinit/#Boundary-Layer-Initialization","page":"Boundary Layer Initialization","title":"Boundary Layer Initialization","text":"","category":"section"},{"location":"blinit/","page":"Boundary Layer Initialization","title":"Boundary Layer Initialization","text":"In order to avoid instabilities and help the convergence of the numerical system this tecnique is adopted. It is based on the resolution of the p-poisson, [4]. The algorithm used to solve the non-linear p-Poisson, equation \\eqref{equ:ppoisson} equation resembles the Picard method.","category":"page"},{"location":"blinit/","page":"Boundary Layer Initialization","title":"Boundary Layer Initialization","text":"nabla cdot (nabla u_p^p-2 nabla u_p) = -1  xin Omega u_p = 0  xin Omega_D","category":"page"},{"location":"blinit/","page":"Boundary Layer Initialization","title":"Boundary Layer Initialization","text":"The idea is to compute the wall-normal distance, from the airfoil, for each point of the domain. Then setting a threshold based on the Reynolds number, the velocity in the area close to the airfoil follows a cubic function.","category":"page"},{"location":"blinit/","page":"Boundary Layer Initialization","title":"Boundary Layer Initialization","text":"(Image: Velocity initialization)","category":"page"},{"location":"blinit/#How-to-use-it","page":"Boundary Layer Initialization","title":"How to use it","text":"","category":"section"},{"location":"blinit/","page":"Boundary Layer Initialization","title":"Boundary Layer Initialization","text":"It is possible to initialize the airfoil simulation using the WallDistance module. It works only in serial and for 2D meshes but it is possible to initilize a 3D solution from a 2D results.","category":"page"},{"location":"blinit/","page":"Boundary Layer Initialization","title":"Boundary Layer Initialization","text":"using SegregatedVMSSolver\nusing SegregatedVMSSolver.WallDistance\n\nmesh_file = \"models/DU89_2D_A1_M.msh\"\nD = 2\nu_in = 1.0\nRe = 500e3\nchord = 1.0\nwalltag = [\"airfoil\",\"wake\"]\n\nget_initial_conditions(mesh_file, D, u_in, Re, chord, walltag)","category":"page"},{"location":"blinit/","page":"Boundary Layer Initialization","title":"Boundary Layer Initialization","text":"This will create a Initial_Conditions.vtu which can be open in ParaView and BoundaryLayerInit.csv which can be used to restart the simulation. Only the velocity is initilized, not the pressure.","category":"page"},{"location":"Cases/airfoil/#Airfoil","page":"Airfoil","title":"Airfoil","text":"","category":"section"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"It is one of the most complex and intersting case. The user has to create a proper mesh in gmsh setting the following physical boundaries:","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"inlet for the inlet\noutlet for the outlet\nairfoil for the airfoil walls\nlimits for the top and bottom boundaries","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"info: .geo file\nIn the folder models/geofile/ is possible to find some .geo file created using gmsh both for 3D and 2D simulations. Different parameters can be modified: angle of attack, domain dimension, mesh divisions... feel free to explore it.","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"The velocity at the inlet is incresed from 0.0 arriving to the target value u_in at :t_endramp. This increase the numeric stability. If :t_endramp = :t0 the velocity at the inlet will be immediately :u_in. For numeric stability is better to keep u_in = 1.0, then fix the Reynolds and so the viscosity will be automatically computed as: ν = 1/Reynolds","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"The pressure is set 0.0 at the outlet section. The velocity on the limits is set equal to the one at inlet.","category":"page"},{"location":"Cases/airfoil/#Suggested-workflow","page":"Airfoil","title":"Suggested workflow","text":"","category":"section"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"3D LES are heavy and it is possible to experience divergence issues. It is suggested to use one of the two initilization tecniques: Velocity ramping or Boundary layer initialization","category":"page"},{"location":"Cases/airfoil/#Velocity-ramping","page":"Airfoil","title":"Velocity ramping","text":"","category":"section"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"By setting t_endramp > t0 automatically the code will create an inlet velocity which will increase linearly in time up to the u_in target value.","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"uin(t) = (t < t_endramp) ? (u_in .*(t/t_endramp)) : u_in","category":"page"},{"location":"Cases/airfoil/#Boundary-Layer-initialization","page":"Airfoil","title":"Boundary Layer initialization","text":"","category":"section"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"Details are provided in the dedicated section.","category":"page"},{"location":"Cases/cylinder/#Cylinder","page":"Cylinder","title":"Cylinder","text":"","category":"section"},{"location":"Cases/cylinder/","page":"Cylinder","title":"Cylinder","text":"The Cylinder case can be used to see how meshes created in  gmsh are manged and to obtain the vortex shedding phenomena. The user has to create a proper mesh in gmsh setting the following physical boundaries:","category":"page"},{"location":"Cases/cylinder/","page":"Cylinder","title":"Cylinder","text":"inlet for the inlet\noutlet for the outlet\ncylinder for the cylinder walls\nlimits for the top and bottom boundaries","category":"page"},{"location":"restart/#Restart","page":"Restart","title":"Restart","text":"","category":"section"},{"location":"restart/","page":"Restart","title":"Restart","text":"The package allows to re-start a simulation from a previous stored result by setting: :restart=>true mesh_file=>\"meshfile.csv\"","category":"page"},{"location":"restart/","page":"Restart","title":"Restart","text":"It can read a .csv file with the headers: x y z uh_0 uh_1 uh_2 ph. The ph is optional. For each node coordinates x y z the velocity in the 3 directions is specified.","category":"page"},{"location":"restart/","page":"Restart","title":"Restart","text":"It is also possible to use a 2D solution to start a 3D simulation.","category":"page"},{"location":"#SegregatedVMSSolver.jl","page":"Introduction","title":"SegregatedVMSSolver.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"SegregatedVMSSolver.jl for solving incompressible Navier-Stokes using stabilized Finite Element Method, in specific Streamline-Upwind Petrov-Galerkin (SUPG) and Variational MultiScale method (VMS)","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The package solves the incompressible Navier-Stokes equations using SUPG and VMS method. VMS has been originally introduced by [1]. In specific, a linearized and segregated version of the SUPG (following the steps illustrated by [2]) and VMS is solved. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The methods belong to the Large Eddy Simulation (LES) family. The package can solve the Taylor Green Vortices (only 2D), Lid Driven Cavity Flow (only 2D), Cylinder vortex shedding (only 2D), and general Airfoils (2D and 3D). ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"It works fully in parallel (tested up to 80-CORES). It is specialized for the resolution of flow over airfoils, testing the capability of detecting the Laminar Separation Bubble. It is equipped with some utilities modules for reading the output files and creating proper initial conditions.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The package is registered, so you can install it as:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(SegregatedVMSSolver)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"or from the REPL just press ].","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(@1.8) pkg> add SegregatedVMSSolver","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You can use the most recent release installing it as:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(url=\"https://github.com/carlodev/SegregatedVMSSolver.jl\")","category":"page"},{"location":"#Suggested-software-to-install","page":"Introduction","title":"Suggested software to install","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"For a complete and smooth experience is suggested to install the free software ParaView which allows to graphically visualize the results and open .vtu and .pvtu files. For creating mesh and physical boundary conditions is suggested to install the free software gmsh.","category":"page"},{"location":"#Features","page":"Introduction","title":"Features","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Implementation of SUPG and VMS formulation for same order elements for velocity and pressure\nSolve 3D airfoils geometries, time-dependend, fully parallelized code\nUsing custom Meshes created with gmsh. For airfoils the package AirfoilGmsh.jl has been developed for speeding up the process\nSolve 2D and 3D cases\nPossibility of choosing the backend thanks to PartitionedArrays.jl. It can be run in the REPL for debugging or in MPI","category":"page"},{"location":"#Packages","page":"Introduction","title":"Packages","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"It relies on the  Gridap ecosystem. It is also completely written in Julia and allows parallelization. The MPI and PartititionedArrays are also at the basis of the parallelization.","category":"page"}]
}
