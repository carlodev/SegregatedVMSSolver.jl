var documenterSearchIndex = {"docs":
[{"location":"mpi/#MPI-Run","page":"MPI run","title":"MPI Run","text":"","category":"section"},{"location":"mpi/","page":"MPI run","title":"MPI run","text":"The code can be run in Message Passing Interface (MPI).  The code is made in such a way that it can run:","category":"page"},{"location":"mpi/","page":"MPI run","title":"MPI run","text":"in the REPL, selecting SegregatedVMSSolver.main(simcase,with_debug)\nin MPI, selecting SegregatedVMSSolver.main(simcase,with_mpi)","category":"page"},{"location":"mpi/","page":"MPI run","title":"MPI run","text":"When running in MPI the code cannot be easily executed in the REPL. Instead, one has to run them from a terminal using the mpiexecjl script as provided by MPI.jl. ","category":"page"},{"location":"mpi/","page":"MPI run","title":"MPI run","text":"For example with the command: ","category":"page"},{"location":"mpi/","page":"MPI run","title":"MPI run","text":"mpiexecjl -n 4 julia --project=. run_simulation.jl","category":"page"},{"location":"mpi/","page":"MPI run","title":"MPI run","text":"It is possible to launch the tests changing the backend.","category":"page"},{"location":"mpi/#Run-in-a-Cluster","page":"MPI run","title":"Run in a Cluster","text":"","category":"section"},{"location":"mpi/","page":"MPI run","title":"MPI run","text":"It is possible to run a simulation in a cluster, creating a suitable bash file, example the following run_sim.sh file can be used. The user has to specify where julia is installed and to activate a suitable project where there is SegregatedVMSSolver in the dependancies. The run_simulation.jl is the julia file of the simulation itself. Be sure that the number of processors specified in simulation is corresponding to the number of processors used for running the simulation in the cluster.","category":"page"},{"location":"mpi/","page":"MPI run","title":"MPI run","text":"#!/bin/sh\nexport PATH=$HOME/julia-1.8.5/bin/:$PATH\n\nsrun julia --project=../../../ -O3 --check-bounds=no -L run_simulation.jl","category":"page"},{"location":"mpi/","page":"MPI run","title":"MPI run","text":"This is a command example to launch the simulation on a single node (-N1) a cluster using slurm, using 80 cores -n80, specifing the partition of 80 cores -p80CORE and a total time of 400 hours -t 400:0:0.","category":"page"},{"location":"mpi/","page":"MPI run","title":"MPI run","text":"sbatch -t 400:0:0 -N 1 -n80 -p80CORE run_sim.sh","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"user_params/#User-Parameters","page":"User Parameters","title":"User Parameters","text":"","category":"section"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"The simulation parameters are written step by step by the user. The Physical Parameters are defined in src/Commons/ParametersDef/Params.jl, where the default values are also provided.","category":"page"},{"location":"user_params/#TimeParameters","page":"User Parameters","title":"TimeParameters","text":"","category":"section"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"using SegregatedVMSSolver\nusing PartitionedArrays,MPI\nusing SegregatedVMSSolver.ParametersDef\nt0 = 0.0\ndt = 0.1\ntF = 1.0\n\ntimep = TimeParameters(t0,dt,tF)","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"The user can also specify a time_window::Tuple{Float64,Float64} where to compute the average flow-field. The user can specify a t_endramp, the boundary-velocity is then increased from 0.0 up to the target value following a linear law from t0 up^to t_endramp, it increases stability.","category":"page"},{"location":"user_params/#PhysicalParameters","page":"User Parameters","title":"PhysicalParameters","text":"","category":"section"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"Re = 1000\nc= 1.0\nu_in = 1.0\nphysicalp = PhysicalParameters(Re=Re,c=c,u_in=u_in)","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"The viscosity ν is computed automatically in this way","category":"page"},{"location":"user_params/#SolverParameters","page":"User Parameters","title":"SolverParameters","text":"","category":"section"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"solverp = SolverParameters()","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"In this example we are using the default parameters. It is possible to supply more detailed options, as reported in the file src/Commons/SolverOptions.jl.","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"options = petsc_options(vel_ksp=\"gmres\", vel_pc=\"ilu\")\nsolverp = SolverParameters(petsc_options=options)","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"info: Using HYPRE\nFor solving the Airfoil case, it is suggested to use the option petsc_options_airfoil() which requires the installation of hypre when installing PETSc","category":"page"},{"location":"user_params/#MeshParameters","page":"User Parameters","title":"MeshParameters","text":"","category":"section"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"D = 2\nrank_partition = (2,2)\nmeshp= MeshParameters(rank_partition,D; N=50,L=0.5)","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"The mesh information are supplied. D is the dimension of the problem - 2 or 3. In the example a sqare carthesian mesh is created, with 50 divisions on each side, extending from (-0.5,-0.5) up to (0.5,0.5). The rank_partition is a Tuplespecifing how to split the domainin the different directions. In this case 4 processors are necessary. ","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"airfoil_mesh_file = joinpath(@__DIR__,\"..\", \"..\", \"models\", \"DU89_2D_A1_M.msh\")\nmeshp= MeshParameters(rank_partition,D,airfoil_mesh_file)","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"In this example the mesh is created from a .msh file created using Gmsh.","category":"page"},{"location":"user_params/#ExportParameters","page":"User Parameters","title":"ExportParameters","text":"","category":"section"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"exportp = ExportParameters()","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"It is using the default values.","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"exportp = ExportParameters(printinitial=false,printmodel=false,name_tags=[\"airfoil\"], fieldexport=[[\"uh\"]])","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"In this example, the velocity field (or better, the gradient of the velocity field) corresponding to the airfoil tag is exported at each time step.","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"info: Export `.vtu` files\nExporting .vtu files can rapidly fill the disk space. By default, a .vtu file is exported every 100 time steps. You can enable a continuous exporting of .vtu files creating the following file : Log/PrintSim.txt","category":"page"},{"location":"user_params/#RestartParameters","page":"User Parameters","title":"RestartParameters","text":"","category":"section"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"restartp = RestartParameters()","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"The creation of RestartParameters is optional is not enabled by default. The user can specify a .csv file path containing the columns Points_0,Points_1,Points_2,uh_0,uh_1,uh_2.","category":"page"},{"location":"Cases/liddriven/#Lid-Driven-Cavity-Flow","page":"Lid Driven Cavity Flow","title":"Lid Driven Cavity Flow","text":"","category":"section"},{"location":"Cases/liddriven/","page":"Lid Driven Cavity Flow","title":"Lid Driven Cavity Flow","text":"(Image: Ldx)","category":"page"},{"location":"Cases/liddriven/","page":"Lid Driven Cavity Flow","title":"Lid Driven Cavity Flow","text":"The Lid Driven Cavity flow is another standard case. It is a box of 1x1 dimension with the top side that can slide. The user can set different Reynolds.","category":"page"},{"location":"Cases/liddriven/","page":"Lid Driven Cavity Flow","title":"Lid Driven Cavity Flow","text":"using PartitionedArrays\nusing SegregatedVMSSolver\nusing SegregatedVMSSolver.ParametersDef\nusing SegregatedVMSSolver.SolverOptions\n\nt0 =0.0\ndt = 0.1\ntF = 3.0\nt_endramp=2.0\n\nRe = 1000\nD = 2\nrank_partition = (2,2)\n\n\nsprob = StabilizedProblem(method=VMS(), coeff_method=ScalarFormulation())\ntimep = TimeParameters(t0=t0,dt=dt,tF=tF, t_endramp=t_endramp)\n\nphysicalp = PhysicalParameters(Re=Re)\nsolverp = SolverParameters()\nexportp = ExportParameters(printinitial=false,printmodel=false)\n\n\nmeshp= MeshParameters(rank_partition,D;N=32,L=0.5)\nsimparams = SimulationParameters(timep,physicalp,solverp,exportp)\n\n\nmcase = LidDriven(meshp,simparams,sprob)\n\nSegregatedVMSSolver.main(mcase,with_debug)\n","category":"page"},{"location":"Cases/taylorgreen/#Taylor-Green-Vortex","page":"Taylor Green","title":"Taylor Green Vortex","text":"","category":"section"},{"location":"Cases/taylorgreen/","page":"Taylor Green","title":"Taylor Green","text":"(Image: TGx)","category":"page"},{"location":"Cases/taylorgreen/","page":"Taylor Green","title":"Taylor Green","text":"It solves the 2D Taylor Green Vortex case. It is the only case where analtical solution are available:","category":"page"},{"location":"Cases/taylorgreen/","page":"Taylor Green","title":"Taylor Green","text":"u_x= U_a-V_s cos bigg (fracpiD(x-U_a t)bigg ) sin bigg (fracpiD(y-V_a t)bigg ) e^-frac2 v pi^2D^2 t","category":"page"},{"location":"Cases/taylorgreen/","page":"Taylor Green","title":"Taylor Green","text":"u_y= V_a+V_s sin bigg (fracpiD(x-U_a t)bigg ) cos bigg (fracpiD(y-V_a t)bigg ) e^-frac2 nu pi^2D^2 t","category":"page"},{"location":"Cases/taylorgreen/","page":"Taylor Green","title":"Taylor Green","text":"p=-fracV_s^24bigg ((cos(2 fracpiD(x-U_a t) )+cos (2 fracpiD(y-V_a t))bigg ) e^-frac4 v pi^2D^2 t","category":"page"},{"location":"Cases/taylorgreen/","page":"Taylor Green","title":"Taylor Green","text":"omega=frac2 V_s piD cos bigg (fracpiD(x-U_a t)bigg ) cos bigg (fracpiD(y-V_a t)bigg ) e^-frac4 nu pi^2D^2 t","category":"page"},{"location":"Cases/taylorgreen/","page":"Taylor Green","title":"Taylor Green","text":"Because of an analytical solution it is used as a benchamark case for verifing mesh convergence, CFL stability and processor scalability. The domain is a squqare of 2Dx2D with periodic boundaries over the 4 sides. The initial solution is retrived from the analytical solution. The pressure is fixed in the centre of the domain equal to the analytical solution.  The parameters set by the user are overwritten by the following standard values:","category":"page"},{"location":"Cases/taylorgreen/","page":"Taylor Green","title":"Taylor Green","text":"Vs = 1ms swirling velocity\nUa = 02ms translational velocity in x direction\nVa = 03ms translational  velocity in y direction\nD = 05m vortex dimensions\nnu = 0001 m^2s","category":"page"},{"location":"Cases/taylorgreen/","page":"Taylor Green","title":"Taylor Green","text":"using PartitionedArrays\nusing SegregatedVMSSolver\nusing SegregatedVMSSolver.ParametersDef\nusing SegregatedVMSSolver.SolverOptions\n\n\nt0 =0.0\ndt = 0.1\ntF = 0.5\n\nRe = 1000\nD = 2\nrank_partition = (2,2)\n\n\nsprob = StabilizedProblem(VMS(1))\ntimep = TimeParameters(t0=t0,dt=dt,tF=tF)\n\nphysicalp = PhysicalParameters(Re=Re)\nsolverp = SolverParameters()\nexportp = ExportParameters(printinitial=false,printmodel=false)","category":"page"},{"location":"Cases/taylorgreen/","page":"Taylor Green","title":"Taylor Green","text":"We create a mesh of 32x32 elements","category":"page"},{"location":"Cases/taylorgreen/","page":"Taylor Green","title":"Taylor Green","text":"meshp= MeshParameters(rank_partition,D;N=32,L=0.5)\nsimparams = SimulationParameters(timep,physicalp,solverp,exportp)\n\n\nmcase = TaylorGreen(meshp,simparams,sprob)\n\nSegregatedVMSSolver.main(mcase,with_debug)","category":"page"},{"location":"post_proc/#Post-Processing","page":"Post Processing","title":"Post Processing","text":"","category":"section"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"In this section is explained how to visualize the results and use the integrated post processing api for studying airfoils. All the results are saved in the folder /Results. ","category":"page"},{"location":"post_proc/#Using-Paraview","page":"Post Processing","title":"Using Paraview","text":"","category":"section"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"ParaView which allows to graphically visualize the results and open .vtu and .pvtu files. There are a lot of embedded and avanced tools.","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"info: numeric info\nCreating Log/PrintSim.txt allows to monitor the current state of the simulation creating .pvtu files. It is suggested to use it at the beginning of the simulation to check the convergence of the simulation and the boundary conditions. It may consume a lot of storage space saving all time steps for 3D simulations. ","category":"page"},{"location":"post_proc/#Using-Integrated-API","page":"Post Processing","title":"Using Integrated API","text":"","category":"section"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"A specific module ReadAirfoilResults has been develop. While running an Airfoil simulation the code automatically saves the results - for pressure and velocity normal gradient - just for the nodes that are part of the airfoil boundary. ","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"Use the ReadAirfoilResults module","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"using SegregatedVMSSolver\nusing SegregatedVMSSolver.ReadAirfoilResults","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"Specify the path where the .csv files with the results are stored.  Specify also the geometrical and physical parameters","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"res_path = \"Results/\"\nRe = 500_000\nu0 = 1.0\nc = 1.0\nrho = 1.0\nμ = u0*c*rho/Re\nα = 1.0","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"Get the nodes and normals","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"nodes, normals = get_geometry_info(res_path;α=α)","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"You can get the everage - in time and spanwise direction - of velocity and friction field. It is possible to specify the number of time-step that you want to skip at the beginning of the averaging using the keyword offset. It allows to avoid averaging also the initils time-steps where the solution is still evolving.","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"Ph = time_space_average_field(res_path, \"ph\", nodes)\nVelocity = time_space_average_field(res_path, \"uh\", nodes)\nFriction = time_space_average_field(res_path, \"friction\", nodes)","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"Writing the parameters of the simulation allows the code to get the local values for Cp and Cf distiguishing between top and bottom side. ","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"cp_top, cp_bottom = extract_Cp(nodes, Ph; u0=u0, rho=rho)\nfriction_top, friction_bottom = extract_Cf(nodes, Friction, μ; u0=u0, rho=rho)\n\nCL,CD = compute_CL_CD(nodes, cp_top, cp_bottom,\nfriction_top, friction_bottom; chord=1.0)","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"It is possible to plot the results. For example","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"using Plots\nplot(nodes.top.x, cp_top, label = \"VMS\", color = :red, linewidth = 1.5)\nplot!(nodes.bottom.x,cp_bottom, label = false, color = :red, linewidth = 1.5 )","category":"page"},{"location":"post_proc/#Advanced-Post-Processing","page":"Post Processing","title":"Advanced Post Processing","text":"","category":"section"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"There are also more powerful API to extract velocity fluctuations, TKE and spectra.","category":"page"},{"location":"post_proc/#Time-Averaging","page":"Post Processing","title":"Time Averaging","text":"","category":"section"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"In this example we compute the time-average of the velocity field in the volume \"topairfoil\". The user while creating the mesh has to add this tag to the volume to analyze","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"tagname=\"topairfoil\"\n\ntopairfoil_nodes = get_nodes(res_path;tagname=tagname)\n\nVel_avg_3D = compute_time_average(res_path)\nVel_avg2D = compute_time_span_average(Vel_avg_3D)","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"It is possible to extract one of the components of the average velocity","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"ux_avg = Vel_avg2D[:,1]\nuy_avg = Vel_avg2D[:,2]\nuz_avg = Vel_avg2D[:,3]","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"And to plot it on the plane 0.1","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"xgrid,ygrid,velocity_dense = compute_scatter_interp(res_path, ux_avg, 0.1)\n\nusing Plots\n\n#it can take a while\nscatter(xgrid,ygrid .+ 0.0028;\nzcolor=velocity_dense,markerstrokewidth=0, label=\"U_x average\")","category":"page"},{"location":"post_proc/#Fluctuations","page":"Post Processing","title":"Fluctuations","text":"","category":"section"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"It is possible to create a proble aligned with the z axis in the point xc,yc and get the fluctuations of that line.","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"xc,yc= 0.5,0.1 #it has to be a point of the domain\nzprobe, Vel = read_fluctuations(res_path, [xc,yc]; offset=1_000,offend=5_000)","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"It is also possible to compute the Power Spectral Density (PSD)","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"dt = 0.001\nnt=size(Vel)[1]-1 #Number of time-steps\ntn = collect(0.0:dt:dt*nt)\nPSD,freqs = compute_PSD(Vel, tn)","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"Computing the TKE in the plane 0.1","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"tke_xy = compute_plane_tke(res_path; zp =0.1)","category":"page"},{"location":"post_proc/","page":"Post Processing","title":"Post Processing","text":"info: OutOfMemory() Error\nProcessing Large Amount of data can saturate all the RAM available on your system. Try changing machines or reducing the admount of data to process.","category":"page"},{"location":"sim_params/#Simulation-Parameters","page":"Simulation Parameters","title":"Simulation Parameters","text":"","category":"section"},{"location":"sim_params/","page":"Simulation Parameters","title":"Simulation Parameters","text":"The simualtion parameters are used to solve the incompressible Navier-Stokes problem.","category":"page"},{"location":"sim_params/","page":"Simulation Parameters","title":"Simulation Parameters","text":"The Simulation Parameters are defined in src/Commons/ParametersDef/StabilizationStruct.jl, where the default values are also provided.","category":"page"},{"location":"sim_params/","page":"Simulation Parameters","title":"Simulation Parameters","text":"using SegregatedVMSSolver\nusing SegregatedVMSSolver.ParametersDef\n\nsprob = StabilizedProblem()","category":"page"},{"location":"sim_params/","page":"Simulation Parameters","title":"Simulation Parameters","text":"The user is creating a StabilizedProblem using the default options. It is possible to specify:","category":"page"},{"location":"sim_params/","page":"Simulation Parameters","title":"Simulation Parameters","text":"method: VMS() or SUPG() where also the order of elements can be specified\ncoeff_method: TensorFormulation(), ScalarFormulation(). Stabilization coefficients r and Ci can be provided.\nskew: enable a skew-symmetric formulation","category":"page"},{"location":"sim_params/","page":"Simulation Parameters","title":"Simulation Parameters","text":"sprob = StabilizedProblem(method=SUPG(1), coeff_method=TensorFormulation(Ci=[2,16], r=2), skew=true)","category":"page"},{"location":"sim_params/","page":"Simulation Parameters","title":"Simulation Parameters","text":"In this example the StabilizedProblem is using a SUPG resolution, using first order elements, a method to compute the coeffients based on the tensor formulation, with the supplied coefficients and a skew symmetric formulation of the conservation equations.","category":"page"},{"location":"api_info/#Index","page":"API information","title":"Index","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"CurrentModule = SegregatedVMSSolver.ParametersDef","category":"page"},{"location":"api_info/#ParametersDef","page":"API information","title":"ParametersDef","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"Modules = [ParametersDef,]","category":"page"},{"location":"api_info/#SegregatedVMSSolver.ParametersDef.analytical_solution-NTuple{5, Any}","page":"API information","title":"SegregatedVMSSolver.ParametersDef.analytical_solution","text":"analytical_solution(diameter::Int64, Vs::Float64, Ua::Float64, Va::Float64, ν::Float64)\n\nIt provides the anlytical solution for the Taylor Green Vortex case.\n\n\n\n\n\n","category":"method"},{"location":"api_info/","page":"API information","title":"API information","text":"CurrentModule = SegregatedVMSSolver.CreateProblem","category":"page"},{"location":"api_info/#CreateProblem","page":"API information","title":"CreateProblem","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"Modules = [CreateProblem,]","category":"page"},{"location":"api_info/#SegregatedVMSSolver.CreateProblem.add_SEM_tag!-Tuple{Any}","page":"API information","title":"SegregatedVMSSolver.CreateProblem.add_SEM_tag!","text":"add the SEM tag to the nodes in front of the airfoil. c: chord of the airfoil, the points are on a circle at 1 chord of distance from the leading edge.  set a_tol for selecting only one lines of points, it depends on how fine the mesh is. \n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.CreateProblem.add_centre_tag!-Tuple{Any, Gridap.TensorValues.VectorValue}","page":"API information","title":"SegregatedVMSSolver.CreateProblem.add_centre_tag!","text":"add_centre_tag!(model, tag_coordinate::Point)\n\nIt creates the centre tag at the tag_coordinate (Point); if mesh extremely fine the tolrances have to be smaller (unlikely)\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.CreateProblem.add_new_tag!-Tuple{Any, Gridap.TensorValues.VectorValue, String}","page":"API information","title":"SegregatedVMSSolver.CreateProblem.add_new_tag!","text":"add_new_tag!(model, tag_coordinate::Point, tagname::String)\n\nIt add a new tag named tagname at the specified tag_coordinates    \n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.CreateProblem.create_initial_conditions-Tuple{Union{Airfoil, Cylinder, LidDriven, WindTunnel}, Dict{Symbol, Any}}","page":"API information","title":"SegregatedVMSSolver.CreateProblem.create_initial_conditions","text":"create_initial_conditions(simcase::SimulationCase)\n\nIt creates the initial conditions for velocity and pressure. If restart is true then the velocity and the pressure field are interpoled on the specified DataFrame.  \n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.CreateProblem.create_new_tag!-Tuple{GridapDistributed.DistributedDiscreteModel, String, Function}","page":"API information","title":"SegregatedVMSSolver.CreateProblem.create_new_tag!","text":"create_new_tag!(model::GridapDistributed.DistributedDiscreteModel, tagname::String, is_tag::Function)\n\nIt creates the centre tag at the tag_coordinate (Point); if mesh extremely fine the tolrances have to be smaller (unlikely)\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.CreateProblem.create_search_tree-Tuple{DataFrames.DataFrame}","page":"API information","title":"SegregatedVMSSolver.CreateProblem.create_search_tree","text":"create_search_tree(restart_df::DataFrame)\n\nCreate a BruteTree from the NearestNeighbors.jl package taking the coordinates points as input\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.CreateProblem.print_model-Tuple{Any, SegregatedVMSSolver.ParametersDef.SimulationCase}","page":"API information","title":"SegregatedVMSSolver.CreateProblem.print_model","text":"print_model(model,simcase::SimulationCase)\n\nIt prints the model mesh\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.CreateProblem.restart_ph_field-Tuple{Any, DataFrames.DataFrame}","page":"API information","title":"SegregatedVMSSolver.CreateProblem.restart_ph_field","text":"restart_ph_field(simcase::VelocityBoundary,tree)\n\nIt provides a suitable function which gives for each point the specified pressure in restart_file. It is used as initial condition for restarting a simulation at a specific time step.\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.CreateProblem.restart_uh_field-Tuple{Int64, Any, DataFrames.DataFrame}","page":"API information","title":"SegregatedVMSSolver.CreateProblem.restart_uh_field","text":"restart_uh_field(D::Int64,tree,restart_df::DataFrame)\n\nIt provides a suitable function which gives for each point the specified velocity in restart_file. It is used as initial condition for restarting a simulation at a specific time step.\n\n\n\n\n\n","category":"method"},{"location":"api_info/","page":"API information","title":"API information","text":"CurrentModule = SegregatedVMSSolver.Equations","category":"page"},{"location":"api_info/#Equations","page":"API information","title":"Equations","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"Modules = [Equations,]","category":"page"},{"location":"api_info/#SegregatedVMSSolver.Equations.G_params-Tuple{Gridap.Geometry.Triangulation, Int64}","page":"API information","title":"SegregatedVMSSolver.Equations.G_params","text":"G_params(Ω::Triangulation, D)\n\nCompute the tensor G and the values GG and gg according to the VMS formulation proposed by [4] \n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.Equations.cconv-Tuple{Any, Any}","page":"API information","title":"SegregatedVMSSolver.Equations.cconv","text":"cconv(uadv, ∇u) \n\nWrapper for the convective term   u(nabla u)  \n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.Equations.compute_G-Tuple{Gridap.Geometry.BodyFittedTriangulation, Int64}","page":"API information","title":"SegregatedVMSSolver.Equations.compute_G","text":"compute_G(trian::Gridap.Geometry.BodyFittedTriangulation, D::Int64)\n\nCompute G (AbstractArray of TensorValues)\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.Equations.compute_GG-Tuple{Gridap.Geometry.BodyFittedTriangulation, Int64}","page":"API information","title":"SegregatedVMSSolver.Equations.compute_GG","text":"compute_GG(trian::Gridap.Geometry.BodyFittedTriangulation, params)\n\nCompute GG \n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.Equations.compute_d-Tuple{Gridap.Geometry.BodyFittedTriangulation, Int64}","page":"API information","title":"SegregatedVMSSolver.Equations.compute_d","text":"compute_d(trian::Gridap.Geometry.BodyFittedTriangulation, D::Int64) #trian == Ω\n\nThe inverse of the cell-map-field. It is evaluted in the middle of the refernce domain.\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.Equations.compute_gg-Tuple{Gridap.Geometry.BodyFittedTriangulation, Int64}","page":"API information","title":"SegregatedVMSSolver.Equations.compute_gg","text":"compute_GG(trian::Gridap.Geometry.BodyFittedTriangulation, D::Int64)\n\nCompute gg \n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.Equations.continuity_stabilization-Tuple{Any, SegregatedVMSSolver.ParametersDef.ScalarStabilization, SegregatedVMSSolver.ParametersDef.SimulationCase}","page":"API information","title":"SegregatedVMSSolver.Equations.continuity_stabilization","text":"continuity_stabilization(uu, stab_coeff::ScalarStabilization,simcase::SimulationCase )\n\nStabilization parameters continuity equation Janssens, B. (2014). Numerical modeling and experimental investigation of ﬁne particle coagulation and dispersion in dilute ﬂows.\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.Equations.continuity_stabilization-Tuple{Any, SegregatedVMSSolver.ParametersDef.TensorStabilization, SegregatedVMSSolver.ParametersDef.SimulationCase}","page":"API information","title":"SegregatedVMSSolver.Equations.continuity_stabilization","text":"continuity_stabilization(uu, stab_coeff::TensorStabilization,simcase::SimulationCase )\n\nStabilization parameter continuity Bazilevs, Y., Calo, V. M., Cottrell, J. A., Hughes, T. J. R., Reali, A., & Scovazzi, G. (2007). Variational multiscale residual-based turbulence modeling for large eddy simulation of incompressible flows. Computer Methods in Applied Mechanics and Engineering, 197(1–4), 173–201. https://doi.org/10.1016/j.cma.2007.07.016\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.Equations.h_param-Tuple{Gridap.Geometry.Triangulation, Int64}","page":"API information","title":"SegregatedVMSSolver.Equations.h_param","text":"h_param(Ω::Triangulation, D::Int64)\n\nFor a given triangulation Ω it computes the cell size Area^12 D=2 Volume^13 D=3\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.Equations.momentum_stabilization-Tuple{Any, SegregatedVMSSolver.ParametersDef.ScalarStabilization, SegregatedVMSSolver.ParametersDef.SimulationCase}","page":"API information","title":"SegregatedVMSSolver.Equations.momentum_stabilization","text":"momentum_stabilization(uu, stab_coeff::ScalarStabilization,simcase::SimulationCase )\n\nStabilization parameters momentum equation Janssens, B. (2014). Numerical modeling and experimental investigation of ﬁne particle coagulation and dispersion in dilute ﬂows.\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.Equations.momentum_stabilization-Tuple{Any, SegregatedVMSSolver.ParametersDef.TensorStabilization, SegregatedVMSSolver.ParametersDef.SimulationCase}","page":"API information","title":"SegregatedVMSSolver.Equations.momentum_stabilization","text":"momentum_stabilization(uu, stab_coeff::TensorStabilization,simcase::SimulationCase )\n\nStabilization parameter momentum stabilization Bazilevs, Y., Calo, V. M., Cottrell, J. A., Hughes, T. J. R., Reali, A., & Scovazzi, G. (2007). Variational multiscale residual-based turbulence modeling for large eddy simulation of incompressible flows. Computer Methods in Applied Mechanics and Engineering, 197(1–4), 173–201. https://doi.org/10.1016/j.cma.2007.07.016\n\n\n\n\n\n","category":"method"},{"location":"api_info/","page":"API information","title":"API information","text":"CurrentModule = SegregatedVMSSolver.MatrixCreation","category":"page"},{"location":"api_info/#MatrixCreation","page":"API information","title":"MatrixCreation","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"Modules   = [MatrixCreation]","category":"page"},{"location":"api_info/#SegregatedVMSSolver.MatrixCreation.allocate_Mat_inv_ML-Tuple{PartitionedArrays.PSparseMatrix}","page":"API information","title":"SegregatedVMSSolver.MatrixCreation.allocate_Mat_inv_ML","text":"allocate_Mat_inv_ML(Mat_ML::PSparseMatrix)\n\nIt allocates a zero vector where to store the inverse of the lumped matrix\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.MatrixCreation.compute_matrices-Tuple{Any, Any, Real, Any, Any, Any}","page":"API information","title":"SegregatedVMSSolver.MatrixCreation.compute_matrices","text":"compute_matrices(trials, tests, t::Real, u_adv, params,simcase)\n\nIt updates matrices and vectors\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.MatrixCreation.initialize_vectors-Tuple{Tuple, Any, Any}","page":"API information","title":"SegregatedVMSSolver.MatrixCreation.initialize_vectors","text":"initialize_vectors(matrices::Tuple,uh0,ph0)\n\nIt initializes vectors where velocity, pressure, acceleration and all the increments will be stored.\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.MatrixCreation.inv_lump_vel_mass!-Tuple{PartitionedArrays.PVector, PartitionedArrays.PSparseMatrix}","page":"API information","title":"SegregatedVMSSolver.MatrixCreation.inv_lump_vel_mass!","text":"inv_lump_vel_mass!(Mat_inv_ML::PVector,Mat_ML::PSparseMatrix)\n\nIt computes the lumped matrix, takes the inverse of the diagonal elements.\n\n\n\n\n\n","category":"method"},{"location":"api_info/","page":"API information","title":"API information","text":"CurrentModule = SegregatedVMSSolver.SolverOptions","category":"page"},{"location":"api_info/#SolverOptions","page":"API information","title":"SolverOptions","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"Modules   = [SolverOptions]","category":"page"},{"location":"api_info/#SegregatedVMSSolver.SolverOptions.create_PETSc_setup-Tuple{AbstractMatrix, Function}","page":"API information","title":"SegregatedVMSSolver.SolverOptions.create_PETSc_setup","text":"create_PETSc_setup(M::AbstractMatrix,ksp_setup::Function)\n\nWrapper for creating PETSc symbolic and numeric setup for GridapPETSc  \n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.SolverOptions.petsc_options-Tuple{}","page":"API information","title":"SegregatedVMSSolver.SolverOptions.petsc_options","text":"petsc_options(; vel_ksp=\"gmres\", vel_pc=\"gamg\", pres_ksp = \"cg\", pres_pc = \"gamg\")\n\nIt provides the command-line for GridapPETSc to solve the segregated linear systems\n\n\n\n\n\n","category":"method"},{"location":"api_info/","page":"API information","title":"API information","text":"CurrentModule = SegregatedVMSSolver.VectorsOperations","category":"page"},{"location":"api_info/#VectorsOperations","page":"API information","title":"VectorsOperations","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"Modules   = [VectorsOperations]","category":"page"},{"location":"api_info/#SegregatedVMSSolver.VectorsOperations.create_ũ_vector-Tuple{AbstractVector}","page":"API information","title":"SegregatedVMSSolver.VectorsOperations.create_ũ_vector","text":"create_ũ_vector(zfv1::AbstractVector)\n\nIt allocates the vector to keep in memory the velocity field up to previous 4 time steps\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.VectorsOperations.set_zeros!-Tuple{PartitionedArrays.DebugArray}","page":"API information","title":"SegregatedVMSSolver.VectorsOperations.set_zeros!","text":"set_zeros!(fields::DebugArray)\n\nSet zeros as free values for a field\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.VectorsOperations.update_ũ-Tuple{Vector}","page":"API information","title":"SegregatedVMSSolver.VectorsOperations.update_ũ","text":"updateũ(ũvec::Vector)\n\nIt uses the Taylor expansion proposed by [5]\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.VectorsOperations.update_ũ_vector!-Tuple{Vector, AbstractVector}","page":"API information","title":"SegregatedVMSSolver.VectorsOperations.update_ũ_vector!","text":"update_ũ_vector!(ũ_vec::Vector, uh_new::AbstractVector)\n\nIt updates the vector which stores the values of velocity at previous time steps.\n\n\n\n\n\n","category":"method"},{"location":"api_info/","page":"API information","title":"API information","text":"CurrentModule = SegregatedVMSSolver.ExportUtility","category":"page"},{"location":"api_info/#ExportUtility","page":"API information","title":"ExportUtility","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"Modules   = [ExportUtility]","category":"page"},{"location":"api_info/#SegregatedVMSSolver.ExportUtility.compute_error-Tuple{Dict{Symbol, Any}, TaylorGreen, Float64, Tuple}","page":"API information","title":"SegregatedVMSSolver.ExportUtility.compute_error","text":"compute_error(params::Dict{Symbol,Any}, simcase::TaylorGreen, tn::Float64, fields::Tuple)\n\nIt computes the velocity and pressure L2 error for the Taylor-Green case \n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ExportUtility.conv_to_df-Tuple{Vector{Float64}}","page":"API information","title":"SegregatedVMSSolver.ExportUtility.conv_to_df","text":"conv_to_df(vv::Vector)\n\nConvert a Vector{Float64} to a DataFrame. It is used for export pressure field.\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ExportUtility.conv_to_df-Tuple{Vector}","page":"API information","title":"SegregatedVMSSolver.ExportUtility.conv_to_df","text":"conv_to_df(vv::Vector)\n\nConvert a Vector{Vector} to a DataFrame. It is used for export nodes, normals.\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ExportUtility.create_export_tags!-Tuple{Dict{Symbol, Any}, Vector}","page":"API information","title":"SegregatedVMSSolver.ExportUtility.create_export_tags!","text":"create_export_tags!(params::Dict{Symbol,Any})\n\nFor each ´nametags´ it creates the ´exporttags´ dictionary\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ExportUtility.export_fields-Tuple{Dict{Symbol, Any}, Vector, Float64, Any, Any}","page":"API information","title":"SegregatedVMSSolver.ExportUtility.export_fields","text":"export_fields(params::Dict{Symbol,Any}, fieldexport::Vector, tt::Float64, uh0, ph0)\n\nExport pressure and friction (not multiplied by viscosity) - airfoil simulations oriented\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ExportUtility.print_on_request-Tuple{String}","page":"API information","title":"SegregatedVMSSolver.ExportUtility.print_on_request","text":"print_on_request(log_dir::String)\n\nIf in the directory log_dir exists and there is the PrintSim.txt file return true. If true is printing simulations results in Paraview format (.vtu and .pvtu). \n\n\n\n\n\n","category":"method"},{"location":"api_info/","page":"API information","title":"API information","text":"CurrentModule = SegregatedVMSSolver.SolveProblem","category":"page"},{"location":"api_info/#SolveProblem","page":"API information","title":"SolveProblem","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"Modules   = [SolveProblem]","category":"page"},{"location":"api_info/#SegregatedVMSSolver.SolveProblem.solve_case-Tuple{Dict{Symbol, Any}, SegregatedVMSSolver.ParametersDef.SimulationCase}","page":"API information","title":"SegregatedVMSSolver.SolveProblem.solve_case","text":"solve_case(params::Dict{Symbol,Any})\n\nIt solves iteratively the velocity and pressure system.\n\n\n\n\n\n","category":"method"},{"location":"api_info/","page":"API information","title":"API information","text":"CurrentModule = SegregatedVMSSolver.ReadAirfoilResults","category":"page"},{"location":"api_info/#Utils","page":"API information","title":"Utils","text":"","category":"section"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"Modules = [ ReadAirfoilResults,]","category":"page"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.XYPlane","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.XYPlane","text":"XYPlane\n\nGive a zp coordinate, it gives the indexes of the points in that XY plane\n\n\n\n\n\n","category":"type"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.ZProbe","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.ZProbe","text":"ZProbe\n\nGive a 2D point coordinate xp, yp, it gived the idx of the points aligned in the z direction\n\n\n\n\n\n","category":"type"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.average_3D_field-Tuple{SegregatedVMSSolver.ReadAirfoilResults.GeometryNodes{SegregatedVMSSolver.ReadAirfoilResults.D3}, DataFrames.DataFrame}","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.average_3D_field","text":"average_3D_field(nodes::GeometryNodes{D3}, df_field::DataFrame)\n\nIt is averaging the dataframes value over the points aligned in the z direction\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.average_3D_field-Tuple{String, String}","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.average_3D_field","text":"average_3D_field(path::String, field_name::String; offset=1, offend = 0, step::Int64=1, tagname=\"airfoil\")\n\nIt provides Array{DataFrame}, where each element is a DataFrame at a single time step of the average in z direction.\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.compute_CL_CD-Tuple{SegregatedVMSSolver.ReadAirfoilResults.GeometryNodes, Any, Any, Any, Any}","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.compute_CL_CD","text":"compute_CL_CD(top_nodesx,bottom_nodesx,top_nodesy,bottom_nodesy,cp_top,cp_bottom,\nfriction_top,friction_bottom; chord = 1.0)\n\nIt computes lift and drag coefficients\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.compute_PSD-Tuple{Array, Vector{Float64}}","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.compute_PSD","text":"compute_PSD(Vel::Array, tn::Vector{Float64})\n\nIt computes the PSD of the TKE. Vel is the result obtained through read_fluctuations. The spectras are averaged in the Z direction \n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.compute_plane_tke-Tuple{String}","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.compute_plane_tke","text":"compute_plane_tke(res_path::String;tagname=\"topairfoil\", offset=1,offend=-1, zp=[0.1])\n\nIt computes the TKE for each point in the plane with Z=Zp.\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.compute_scatter_interp-Tuple{Any, Vector{Float64}, Float64}","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.compute_scatter_interp","text":"compute_scatter_interp(res_path, velocity::Vector{Float64} ,zp::Float64; tagname=\"topairfoil\", ylims=[-0.018,0.15], xlims=[0.5,1.0])\n\nIn res_path is reading the nodes file associated with the tagname. It computes the interpolation of the values in velocity on nodes of plane in zp. NearestNeighbor() algorithm is used.\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.extract_Cf-Tuple{SegregatedVMSSolver.ReadAirfoilResults.GeometryNodes, DataFrames.DataFrame, Float64}","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.extract_Cf","text":"extract_Cf(nodes::GeometryNodes, Friction::DataFrame; u0::Float64, μ::Float64, rho::Float64)\n\nFor a given set of nodes and Ph dataframe, it provides the friction coefficient for top and bottom\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.extract_Cp-Tuple{SegregatedVMSSolver.ReadAirfoilResults.GeometryNodes, DataFrames.DataFrame}","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.extract_Cp","text":"extract_Cp(nodes::GeometryNodes, Ph::DataFrame ; u0::Float64, rho::Float64)\n\nFor a given set of nodes and Ph dataframe, it provides the pressure coefficient for top and bottom\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.get_idx_sort_reduct-Tuple{String, String, Int64, Int64}","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.get_idx_sort_reduct","text":"get_idx_sort_reduct(res_path::String,tagname::String,offset::Int64,offend::Int64)\n\nIn res_path directory, for the boundary tagname, it provides the sorted file indexes\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.get_nodes-Tuple{String}","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.get_nodes","text":"get_nodes(path::String)\n\nIt provides a DataFrame with the nodes of the Airfoil boundary\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.get_normals-Tuple{String}","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.get_normals","text":"get_nodes(path::String)\n\nIt provides a DataFrame with the normals vectors at the surface of the Airfoil boundary    \n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.read_fluctuations-Tuple{String, Vector{Float64}}","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.read_fluctuations","text":"read_fluctuations(res_path::String, xpyp::Vector{Float64};tagname=\"topairfoil\", offset=1,offend=-1)\n\nIt is reading the results in res_path, for all the points aligned in Z direction of coordinates xpyp.  It provides the ZProbe which has the information of the actual nodes used. Vel_Mat is a dense matrix: Time x Points x Velocity Components (3) offset and offend can be used to skip intial and final files (avoiding OutOfMemory() error)\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.time_space_average_field-Tuple{String, String, SegregatedVMSSolver.ReadAirfoilResults.GeometryNodes}","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.time_space_average_field","text":"time_space_average_field(path::String, field_name::String, nodes::GeometryNodes; offset=1, offend = 0, step::Int64=1, tagname=\"airfoil\")\n\nIt computes a time and span-average for a specific field. \n\n\n\n\n\n","category":"method"},{"location":"api_info/","page":"API information","title":"API information","text":"CurrentModule = SegregatedVMSSolver.WallDistance","category":"page"},{"location":"api_info/#SegregatedVMSSolver.WallDistance","page":"API information","title":"SegregatedVMSSolver.WallDistance","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"Modules = [ WallDistance,]","category":"page"},{"location":"api_info/#SegregatedVMSSolver.WallDistance.boundary_layer_height-Tuple{Real, Float64}","page":"API information","title":"SegregatedVMSSolver.WallDistance.boundary_layer_height","text":"boundary_layer_height(Re::Real, L::Float64)\n\nFrom Reynolds and characteristic dimension extimates the boundary layer height\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.WallDistance.boundary_layer_quadratic_profile-Tuple{Any, Float64, Real}","page":"API information","title":"SegregatedVMSSolver.WallDistance.boundary_layer_quadratic_profile","text":"boundary_layer_quadratic_profile(x, δ99::Float64, u_in::Real)\n\nParabolic approximation for boundary layer growth\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.WallDistance.get_initial_conditions-Tuple{String, Float64, Real, Any}","page":"API information","title":"SegregatedVMSSolver.WallDistance.get_initial_conditions","text":"getinitialconditions(meshfile::String, uin::Float64, Re::Real, walltag; chord::Float64=1.0, D::Int64=2, p::Int64=6)\n\nIt runs Picard iterations of the p-Poisson problem up to p=6 with relaxation factor of 0.5. It is require p>3 It creates the .vtu file with the boundary layer initialization and also the .csv file which can be used to start a simulation over an airfoil. It return a dataframe where for each nodes are provided the coordinates and the velocity vector components.\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.WallDistance.intialize_picard_iteration-NTuple{4, Any}","page":"API information","title":"SegregatedVMSSolver.WallDistance.intialize_picard_iteration","text":"intialize_picard_iteration(solver, Vg, V0, dΩ)\n\nSolve the p poisson for p=1\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.WallDistance.run_picard_iteration-Tuple{Any, Any, Any, Any, Any, Int64, Float64}","page":"API information","title":"SegregatedVMSSolver.WallDistance.run_picard_iteration","text":"run_picard_iteration(solver, Vg, V0, dΩ, uh_adv, p, γ)\n\nSolve the linearized p-Poisson. uh_adv is the solution at the previous iteration. γ is the relaxation parameter.\n\n\n\n\n\n","category":"method"},{"location":"blinit/#Boundary-Layer-Initialization","page":"Boundary Layer Initialization","title":"Boundary Layer Initialization","text":"","category":"section"},{"location":"blinit/","page":"Boundary Layer Initialization","title":"Boundary Layer Initialization","text":"In order to avoid instabilities and help the convergence of the numerical system this tecnique is adopted. It is based on the resolution of the p-poisson, [3]. The algorithm used to solve the non-linear p-Poisson, equation \\eqref{equ:ppoisson} equation resembles the Picard method.","category":"page"},{"location":"blinit/","page":"Boundary Layer Initialization","title":"Boundary Layer Initialization","text":"nabla cdot (nabla u_p^p-2 nabla u_p) = -1  xin Omega u_p = 0  xin Omega_D","category":"page"},{"location":"blinit/","page":"Boundary Layer Initialization","title":"Boundary Layer Initialization","text":"The idea is to compute the wall-normal distance, from the airfoil, for each point of the domain. Then setting a threshold based on the Reynolds number, the velocity in the area close to the airfoil follows a cubic function.","category":"page"},{"location":"blinit/","page":"Boundary Layer Initialization","title":"Boundary Layer Initialization","text":"(Image: Velocity initialization)","category":"page"},{"location":"blinit/#How-to-use-it","page":"Boundary Layer Initialization","title":"How to use it","text":"","category":"section"},{"location":"blinit/","page":"Boundary Layer Initialization","title":"Boundary Layer Initialization","text":"It is possible to initialize the airfoil simulation using the WallDistance module. It works only in serial and for 2D meshes but it is possible to initilize a 3D solution from a 2D results.","category":"page"},{"location":"blinit/","page":"Boundary Layer Initialization","title":"Boundary Layer Initialization","text":"using SegregatedVMSSolver\nusing SegregatedVMSSolver.WallDistance\n\nmesh_file = \"models/DU89_2D_A1_M.msh\"\nD = 2\nu_in = 1.0\nRe = 500e3\nchord = 1.0\nwalltag = [\"airfoil\",\"wake\"]\n\nget_initial_conditions(mesh_file, D, u_in, Re, chord, walltag)","category":"page"},{"location":"blinit/","page":"Boundary Layer Initialization","title":"Boundary Layer Initialization","text":"This will create a Initial_Conditions.vtu which can be open in ParaView and BoundaryLayerInit.csv which can be used to restart the simulation. Only the velocity is initilized, not the pressure.","category":"page"},{"location":"Cases/airfoil/#Airfoil","page":"Airfoil","title":"Airfoil","text":"","category":"section"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"(Image: LSB-s7003)","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"It is one of the most complex and intersting case. The user has to create a proper mesh in gmsh setting the following physical boundaries:","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"inlet for the inlet\noutlet for the outlet\nairfoil for the airfoil walls\nlimits for the top and bottom boundaries","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"info: .geo file\nIn the folder models/geofile/ is possible to find some .geo file created using gmsh both for 3D and 2D simulations. Different parameters can be modified: angle of attack, domain dimension, mesh divisions... feel free to explore it.","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"The velocity at the inlet is incresed from 0.0 arriving to the target value u_in at :t_endramp. This increase the numeric stability. If :t_endramp = :t0 the velocity at the inlet will be immediately :u_in. For numeric stability is better to keep u_in = 1.0, then fix the Reynolds and so the viscosity will be automatically computed as: ν = 1/Reynolds","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"The pressure is set 0.0 at the outlet section. The velocity on the limits is set equal to the one at inlet.","category":"page"},{"location":"Cases/airfoil/#Suggested-workflow","page":"Airfoil","title":"Suggested workflow","text":"","category":"section"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"3D LES are heavy and it is possible to experience divergence issues. It is suggested to use one of the two initilization tecniques: Velocity ramping or Boundary layer initialization","category":"page"},{"location":"Cases/airfoil/#Velocity-ramping","page":"Airfoil","title":"Velocity ramping","text":"","category":"section"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"By setting t_endramp > t0 automatically the code will create an inlet velocity which will increase linearly in time up to the u_in target value.","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"using PartitionedArrays\nusing MPI\nusing SegregatedVMSSolver\nusing SegregatedVMSSolver.ParametersDef\nusing SegregatedVMSSolver.SolverOptions","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"Calling the dependencies","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"t0 =0.0\ndt = 1e-3\ntF = 5e-3\n\nRe = 10\nD = 2\nrank_partition = (2,2)\nairfoil_mesh_file = joinpath(@__DIR__,\"..\", \"..\", \"models\", \"DU89_2D_A1_M.msh\")","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"timep = TimeParameters(t0,dt,tF)\n\nphysicalp = PhysicalParameters(Re=Re)\nsolverp = SolverParameters(M=2)\nexportp = ExportParameters(printinitial=false,printmodel=false,name_tags=[\"airfoil\"], fieldexport=[[\"uh\"]])\n\nmeshp= MeshParameters(rank_partition,D,airfoil_mesh_file)\nsimparams = SimulationParameters(timep,physicalp,solverp,exportp)","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"Setting the parameters. This simulation will not converge, we are not using a suitable solver which needs hypre.","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"Defining the stabilizatin problem and the simualtion case","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"sprob = StabilizedProblem(VMS(1))\nsimcase = Airfoil(meshp,simparams,sprob)","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"Solve in Sequential - on 1 processor not using MPI, useful for debug.","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":" SegregatedVMSSolver.main(simcase,with_debug)","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"Solve in MPI - for HPC computing","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":" SegregatedVMSSolver.main(simcase,with_mpi)","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"Then in bash give the command. Check the MPI section for more details","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":" mpiexecjl -n 4 julia --project=. run_mysimulation.jl","category":"page"},{"location":"Cases/airfoil/#Boundary-Layer-initialization","page":"Airfoil","title":"Boundary Layer initialization","text":"","category":"section"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"Details are provided in the dedicated section.","category":"page"},{"location":"Cases/cylinder/#Cylinder","page":"Cylinder","title":"Cylinder","text":"","category":"section"},{"location":"Cases/cylinder/","page":"Cylinder","title":"Cylinder","text":"(Image: Cyx)","category":"page"},{"location":"Cases/cylinder/","page":"Cylinder","title":"Cylinder","text":"The Cylinder case can be used to see how meshes created in  gmsh are manged and to obtain the vortex shedding phenomena. The user has to create a proper mesh in gmsh setting the following physical boundaries:","category":"page"},{"location":"Cases/cylinder/","page":"Cylinder","title":"Cylinder","text":"inlet for the inlet\noutlet for the outlet\ncylinder for the cylinder walls\nlimits for the top and bottom boundaries","category":"page"},{"location":"Cases/cylinder/","page":"Cylinder","title":"Cylinder","text":"using PartitionedArrays\nusing SegregatedVMSSolver\nusing SegregatedVMSSolver.ParametersDef\nusing SegregatedVMSSolver.SolverOptions\n\nt0 =0.0\ndt = 0.1\ntF = 0.5\n\nRe = 100\nD = 2\nrank_partition = (2,2)\ncylinder_mesh_file = joinpath(@__DIR__,\"..\", \"..\", \"models\", \"Cylinder_2D.msh\")\n\n\nsprob = StabilizedProblem(SUPG(1))\ntimep = TimeParameters(t0,dt,tF)\n\nphysicalp = PhysicalParameters(Re=Re)\nsolverp = SolverParameters()\nexportp = ExportParameters(printinitial=false,printmodel=false)\n\n\nmeshp= MeshParameters(rank_partition,D,cylinder_mesh_file)\nsimparams = SimulationParameters(timep,physicalp,solverp,exportp)\n\n\nmcase = Cylinder(meshp,simparams,sprob)\n\nSegregatedVMSSolver.main(mcase,backend)","category":"page"},{"location":"restart/#Restart","page":"Restart","title":"Restart","text":"","category":"section"},{"location":"restart/","page":"Restart","title":"Restart","text":"The package allows to re-start a simulation from a previous stored result by setting: :restart=>true mesh_file=>\"meshfile.csv\"","category":"page"},{"location":"restart/","page":"Restart","title":"Restart","text":"It can read a .csv file with the headers: Points_0 Points_1 Points_2 uh_0 uh_1 uh_2 ph. The ph is optional. For each node coordinates x y z the velocity in the 3 directions is specified. Check in folder restarts for examples.","category":"page"},{"location":"restart/","page":"Restart","title":"Restart","text":"It is also possible to use a 2D solution to start a 3D simulation.","category":"page"},{"location":"#SegregatedVMSSolver.jl","page":"Introduction","title":"SegregatedVMSSolver.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"SegregatedVMSSolver.jl for solving incompressible Navier-Stokes using stabilized Finite Element Method, in specific Streamline-Upwind Petrov-Galerkin (SUPG) and Variational MultiScale method (VMS)","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The package solves the incompressible Navier-Stokes equations using SUPG and VMS method. VMS has been originally introduced by [1]. In specific, a linearized and segregated version of the SUPG (following the steps illustrated by [2]) and VMS is solved. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The methods belong to the Large Eddy Simulation (LES) family. The package can solve the Taylor Green Vortices (only 2D), Lid Driven Cavity Flow (only 2D), Cylinder vortex shedding (2D and 3D), and general Airfoils (2D and 3D). ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"It works fully in parallel (tested up to 80-CORES). It is specialized for the resolution of flow over airfoils, testing the capability of detecting the Laminar Separation Bubble. It is equipped with some utilities modules for reading the output files and creating proper initial conditions.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The package is registered, so you can install it as:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(SegregatedVMSSolver)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"or from the REPL just press ].","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(@1.8) pkg> add SegregatedVMSSolver","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You can use the most recent release installing it as:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(url=\"https://github.com/carlodev/SegregatedVMSSolver.jl\")","category":"page"},{"location":"#Suggested-software-to-install","page":"Introduction","title":"Suggested software to install","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"For a complete and smooth experience is suggested to install the free software ParaView which allows to graphically visualize the results and open .vtu and .pvtu files. For creating mesh and physical boundary conditions is suggested to install the free software gmsh.","category":"page"},{"location":"#Features","page":"Introduction","title":"Features","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Implementation of SUPG and VMS formulation for same order elements for velocity and pressure\nSolve 3D airfoils geometries, time-dependend, fully parallelized code\nUsing custom Meshes created with gmsh. For airfoils the package AirfoilGmsh.jl has been developed for speeding up the process\nSolve 2D and 3D cases\nPossibility of choosing the backend thanks to PartitionedArrays.jl. It can be run in the REPL for debugging or in MPI","category":"page"},{"location":"#Packages","page":"Introduction","title":"Packages","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"It relies on the  Gridap ecosystem. It is also completely written in Julia and allows parallelization. The MPI and PartititionedArrays are also at the basis of the parallelization.","category":"page"}]
}
