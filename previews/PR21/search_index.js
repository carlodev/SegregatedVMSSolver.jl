var documenterSearchIndex = {"docs":
[{"location":"mpi/#MPI-Run","page":"MPI run","title":"MPI Run","text":"","category":"section"},{"location":"mpi/","page":"MPI run","title":"MPI run","text":"The code can be run in Message Passing Interface (MPI).  The code is made in such a way that it can run:","category":"page"},{"location":"mpi/","page":"MPI run","title":"MPI run","text":"in the REPL, selecting SegregatedVMSSolver.solve(simcase,with_debug). It is useful to debug the code and visualize errors.\nin MPI, selecting SegregatedVMSSolver.solve(simcase,with_mpi)","category":"page"},{"location":"mpi/","page":"MPI run","title":"MPI run","text":"When running in MPI the code cannot be easily executed in the REPL. Instead, one has to run them from a terminal using the mpiexecjl script as provided by MPI.jl. ","category":"page"},{"location":"mpi/","page":"MPI run","title":"MPI run","text":"For example with the command: ","category":"page"},{"location":"mpi/","page":"MPI run","title":"MPI run","text":"mpiexecjl -n 4 julia --project=. run_simulation.jl","category":"page"},{"location":"mpi/","page":"MPI run","title":"MPI run","text":"It is possible to launch the tests changing the backend.","category":"page"},{"location":"mpi/#Run-in-a-Cluster","page":"MPI run","title":"Run in a Cluster","text":"","category":"section"},{"location":"mpi/","page":"MPI run","title":"MPI run","text":"It is possible to run a simulation in a cluster, creating a suitable bash file, example the following run_sim.sh file can be used. The user has to specify where julia is installed and to activate a suitable project where there is SegregatedVMSSolver in the dependancies. The run_simulation.jl is the julia file of the simulation itself. Be sure that the number of processors specified in simulation is corresponding to the number of processors used for running the simulation in the cluster.","category":"page"},{"location":"mpi/","page":"MPI run","title":"MPI run","text":"#!/bin/sh\nexport PATH=$HOME/julia-1.11.1/bin/:$PATH\n\nsrun julia --project=../../../ -O3 --check-bounds=no -L run_simulation.jl","category":"page"},{"location":"mpi/","page":"MPI run","title":"MPI run","text":"This is a command example to launch the simulation on a single node (-N1) a cluster using slurm, using 80 cores -n80, specifing the partition of 80 cores -p80CORE and a total time of 400 hours -t 400:0:0.","category":"page"},{"location":"mpi/","page":"MPI run","title":"MPI run","text":"sbatch -t 400:0:0 -N 1 -n80 -p80CORE run_sim.sh","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"T. J. Hughes, L. Mazzei and K. E. Jansen. Computing and Visualization in Science Large Eddy Simulation and the variational multiscale method (2000); pp. 47–59.\n\n\n\nB. Janssens. Numerical modeling and experimental investigation of ﬁne particle coagulation    and dispersion in dilute ﬂows. Ph.D. Thesis, Université Libre de Bruxelles (2014).\n\n\n\nO. Botella and R. Peyret. Benchmark spectral results on the lid-driven cavity flow. Computers and Fluids 27, 421–433 (1998).\n\n\n\nC. L. Ladson, A. S. Hill and W. G. Johnson. Pressure Distributions from High Reynolds Number Transonic Tests of an NACA 0012 Airfoil in the Langley 0.3-Meter Transonic Cryogenic Tunnel.\n\n\n\nJ. C. Bakker. Wall-Distance Calcu-lation for Turbulence Modelling (2018).\n\n\n\nY. Bazilevs, V. M. Calo, J. A. Cottrell, T. J. Hughes, A. Reali and G. Scovazzi. Variational multiscale residual-based turbulence modeling for large eddy simulation of incompressible flows. Computer Methods in Applied Mechanics and Engineering 197, 173–201 (2007).\n\n\n\nT. Banyai. Development of Stabilized Finite Element Method for Numerical Simulation of Turbulent Incompressible Single and Eulerian-Eulerian Two-Phase Flows. Ph.D. Thesis, Université Libre de Bruxelles (2016).\n\n\n\n","category":"page"},{"location":"Cases/taylorgreen2D/#Taylor-Green-Vortex-2D","page":"Taylor Green 2D","title":"Taylor Green Vortex 2D","text":"","category":"section"},{"location":"Cases/taylorgreen2D/","page":"Taylor Green 2D","title":"Taylor Green 2D","text":"(Image: TGx)","category":"page"},{"location":"Cases/taylorgreen2D/","page":"Taylor Green 2D","title":"Taylor Green 2D","text":"It solves the Taylor Green Vortex case. ","category":"page"},{"location":"Cases/taylorgreen2D/","page":"Taylor Green 2D","title":"Taylor Green 2D","text":"For the 2D case there is an analytical solution for velocity and pressure:","category":"page"},{"location":"Cases/taylorgreen2D/","page":"Taylor Green 2D","title":"Taylor Green 2D","text":"u_x= U_a-V_s cos bigg (fracpiD(x-U_a t)bigg ) sin bigg (fracpiD(y-V_a t)bigg ) e^-frac2 v pi^2D^2 t","category":"page"},{"location":"Cases/taylorgreen2D/","page":"Taylor Green 2D","title":"Taylor Green 2D","text":"u_y= V_a+V_s sin bigg (fracpiD(x-U_a t)bigg ) cos bigg (fracpiD(y-V_a t)bigg ) e^-frac2 nu pi^2D^2 t","category":"page"},{"location":"Cases/taylorgreen2D/","page":"Taylor Green 2D","title":"Taylor Green 2D","text":"p=-fracV_s^24bigg ((cos(2 fracpiD(x-U_a t) )+cos (2 fracpiD(y-V_a t))bigg ) e^-frac4 v pi^2D^2 t","category":"page"},{"location":"Cases/taylorgreen2D/","page":"Taylor Green 2D","title":"Taylor Green 2D","text":"omega=frac2 V_s piD cos bigg (fracpiD(x-U_a t)bigg ) cos bigg (fracpiD(y-V_a t)bigg ) e^-frac4 nu pi^2D^2 t","category":"page"},{"location":"Cases/taylorgreen2D/","page":"Taylor Green 2D","title":"Taylor Green 2D","text":"Because of an analytical solution it is used as a benchmark case for verifying mesh convergence, CFL stability and processor scalability. The domain is a square of 2Dx2D with periodic boundaries over the 4 sides. The initial solution is obtained from the analytical solution. The pressure is fixed in the centre of the domain equal to the analytical solution.  The parameters set by the user are overwritten by the following standard values:","category":"page"},{"location":"Cases/taylorgreen2D/","page":"Taylor Green 2D","title":"Taylor Green 2D","text":"Vs = 1ms swirling velocity\nUa = 02ms translational velocity in x direction\nVa = 03ms translational  velocity in y direction\nD = 05m vortex dimensions\nnu = 0001 m^2s","category":"page"},{"location":"Cases/taylorgreen2D/","page":"Taylor Green 2D","title":"Taylor Green 2D","text":"using PartitionedArrays\nusing SegregatedVMSSolver\nusing SegregatedVMSSolver.ParametersDef\nusing SegregatedVMSSolver.SolverOptions\n\n\nt0 =0.0\ndt = 0.1\ntF = 0.5\n\nRe = 1000\nD = 2\nrank_partition = (2,2)\n\nbackend = with_debug\n\nsprob = StabilizedProblem(VMS(1))\ntimep = TimeParameters(t0=t0,dt=dt,tF=tF)\n\nphysicalp = PhysicalParameters(Re=Re)\nsolverp = SolverParameters()\nexportp = ExportParameters(printinitial=true, printmodel=true, \nvtu_export = [\"uh\",\"ph\",\"uh_analytic\", \"ph_analytic\"], extra_export=[\"VelocityError\",\"PressureError\"])\n","category":"page"},{"location":"Cases/taylorgreen2D/","page":"Taylor Green 2D","title":"Taylor Green 2D","text":"at each time-step, a new line on a .csv file will be written with: timestep-VelocityError-PressureError in L2 norm. You can use this file to analyze the error decreasing with mesh/order - refinement.","category":"page"},{"location":"Cases/taylorgreen2D/","page":"Taylor Green 2D","title":"Taylor Green 2D","text":"We create a mesh of 32x32 elements","category":"page"},{"location":"Cases/taylorgreen2D/","page":"Taylor Green 2D","title":"Taylor Green 2D","text":"meshp= MeshParameters(rank_partition,D;N=32,L=0.5)\nsimparams = SimulationParameters(timep,physicalp,solverp,exportp)\n\nbc_tgv = Periodic(meshp,physicalp ) \nmcase = TaylorGreen(bc_tgv, meshp,simparams,sprob)\n\nSegregatedVMSSolver.solve(mcase,backend)","category":"page"},{"location":"Cases/taylorgreen2D/","page":"Taylor Green 2D","title":"Taylor Green 2D","text":"It is also possible to use natural boundary conditions:","category":"page"},{"location":"Cases/taylorgreen2D/","page":"Taylor Green 2D","title":"Taylor Green 2D","text":"bc_tgv = Natural(meshp,physicalp) \nmcase = TaylorGreen(bc_tgv, meshp,simparams,sprob)\nSegregatedVMSSolver.solve(mcase,backend)","category":"page"},{"location":"user_params/#User-Parameters","page":"User Parameters","title":"User Parameters","text":"","category":"section"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"The simulation parameters are written step by step by the user. In this section a brief explanation of the main parameters is provided. The Physical Parameters are defined in src/Commons/ParametersDef/Params.jl, where the default values are also provided.","category":"page"},{"location":"user_params/#TimeParameters","page":"User Parameters","title":"TimeParameters","text":"","category":"section"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"using SegregatedVMSSolver\nusing PartitionedArrays,MPI\nusing SegregatedVMSSolver.ParametersDef\nt0 = 0.0\ndt = 0.1\ntF = 10.0\n\ntimep = TimeParameters(t0,dt,tF)","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"The user can also specify a time_window::Tuple{Float64,Float64} where to compute the average flow-field. The user can specify a t_endramp, the boundary-velocity is then increased from 0.0 up to the target value following a linear law from t0 up to t_endramp, it increases stability.","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"TimeParameters(t0=t0,dt=dt,tF=tF, t_endramp=2.0, time_window=(5.0,10.0))","category":"page"},{"location":"user_params/#PhysicalParameters","page":"User Parameters","title":"PhysicalParameters","text":"","category":"section"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"Re = 1000\nc= 1.0\nu_in = [1.0,0.0]\nphysicalp = PhysicalParameters(Re=Re,c=c,u_in=u_in)","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"The viscosity ν is computed automatically in this way","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"physicalp.ν","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"In case of 3D simulation, the initial velocity should be a 3-elements vector.","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"u_in = [1.0,0.0,0.0]","category":"page"},{"location":"user_params/#SolverParameters","page":"User Parameters","title":"SolverParameters","text":"","category":"section"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"solverp = SolverParameters()","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"In this example we are using the default parameters. It is possible to supply more detailed options, as reported in the file src/Commons/SolverOptions.jl.","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"options = petsc_options(vel_ksp=\"gmres\", vel_pc=\"gamg\")\nsolverp = SolverParameters(petsc_options=options)","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"The user can specify  M the maximum number of internal interations for each time-step and the interval to consider after updating the matrices matrix_freq_update.","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"solverp = SolverParameters(M=1, matrix_freq_update=10)","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"info: Using HYPRE\nFor solving the Airfoil case, it is suggested to use the option petsc_options_airfoil() which requires the installation of hypre when installing PETSc","category":"page"},{"location":"user_params/#MeshParameters","page":"User Parameters","title":"MeshParameters","text":"","category":"section"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"For Cartesian cases (Lid-Driven and Taylor-Green)","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"D = 2\nrank_partition = (2,2)\nmeshp= MeshParameters(rank_partition,D; N=50,L=0.5)","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"The mesh information are supplied. D is the dimension of the problem - 2 or 3. In the example a sqare carthesian mesh is created, with 50 divisions on each side, extending from (-0.5,-0.5) up to (0.5,0.5). The rank_partition is a Tuplespecifing how to split the domainin the different directions. In this case 4 processors are necessary. ","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"airfoil_mesh_file = joinpath(@__DIR__,\"..\", \"..\", \"models\", \"DU89_2D_A1_M.msh\")\nmeshp= MeshParameters(rank_partition,D,airfoil_mesh_file)","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"In this example the mesh is created from a .msh file created using Gmsh.","category":"page"},{"location":"user_params/#ExportParameters","page":"User Parameters","title":"ExportParameters","text":"","category":"section"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"exportp = ExportParameters()","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"It is using the default values.","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"The user can choose to export the initial conditions and/or the mesh. It is useful in preliminary stage of simulation design.","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"exportp = ExportParameters(printinitial=true,printmodel=true)","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"The package allows to export the value of velocity, pressure or friction from specific targets on the domain. Example ","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"exportp = ExportParameters(printinitial=true,printmodel=true,name_tags=[\"airfoil\"], fieldexport=[[\"uh\"]])","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"info: Export `.vtu` files\nExporting .vtu files can rapidly fill the disk space. By default, a .vtu file is exported every 100 time steps. You can enable a continuous exporting of .vtu files creating the following file : Log/PrintSim.txt","category":"page"},{"location":"user_params/#InitialParameters","page":"User Parameters","title":"InitialParameters","text":"","category":"section"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"intialp = InitialParameters()","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"The user can specify and initial velocity in the whole domain:","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"intialp = InitialParameters(u0=[0.5,0.1])","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"The package allows to re-start a simulation from a previous stored result. It can read a .csv file with the headers: Points_0 Points_1 Points_2 uh_0 uh_1 uh_2 ph. The ph is optional. For each node coordinates x y z the velocity in the 3 directions is specified. Check in folder restarts for examples of files. It is also possible to use a 2D solution to start a 3D simulation.","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"airfoil_restart_file = joinpath(@__DIR__,\"..\", \"..\", \"restarts\", \"BL_DU89_2D_A1_M.csv\")\nintialp = InitialParameters(airfoil_restart_file)","category":"page"},{"location":"user_params/","page":"User Parameters","title":"User Parameters","text":"The initial file can also be created using the advanced boundary layer initialization. ","category":"page"},{"location":"Cases/liddriven/#Lid-Driven-Cavity-Flow","page":"Lid Driven Cavity Flow","title":"Lid Driven Cavity Flow","text":"","category":"section"},{"location":"Cases/liddriven/","page":"Lid Driven Cavity Flow","title":"Lid Driven Cavity Flow","text":"(Image: Ldx)","category":"page"},{"location":"Cases/liddriven/","page":"Lid Driven Cavity Flow","title":"Lid Driven Cavity Flow","text":"The Lid Driven Cavity flow is another standard case. It is a box of 1x1 dimension with the top side that can slide. The user can set different Reynolds.","category":"page"},{"location":"Cases/liddriven/","page":"Lid Driven Cavity Flow","title":"Lid Driven Cavity Flow","text":"using PartitionedArrays\nusing SegregatedVMSSolver\nusing SegregatedVMSSolver.ParametersDef\nusing SegregatedVMSSolver.SolverOptions\n\nt0 =0.0\ndt = 0.1\ntF = 30.0\nt_endramp=2.0\n\nRe = 1000\nD = 2\nrank_partition = (2,2)\n\n\nsprob = StabilizedProblem(method=VMS(2), coeff_method=ScalarFormulation())\ntimep = TimeParameters(t0=t0,dt=dt,tF=tF, t_endramp=t_endramp)\n\nphysicalp = PhysicalParameters(Re=Re)\nsolverp = SolverParameters()\nexportp = ExportParameters(printinitial=false,printmodel=false)\n\n\nmeshp= MeshParameters(rank_partition,D;N=32,L=0.5)\nsimparams = SimulationParameters(timep,physicalp,solverp,exportp)\n\n\nmcase = LidDriven(meshp,simparams,sprob)\n\nSegregatedVMSSolver.solve(mcase,with_debug)\n","category":"page"},{"location":"Cases/liddriven/#Results","page":"Lid Driven Cavity Flow","title":"Results","text":"","category":"section"},{"location":"Cases/liddriven/","page":"Lid Driven Cavity Flow","title":"Lid Driven Cavity Flow","text":"The reference values are from [3] (Image: LD2D){ width=50%  }","category":"page"},{"location":"Theory/Errors/#Error-Assessment","page":"Error and Parallelization","title":"Error Assessment","text":"","category":"section"},{"location":"Theory/Errors/","page":"Error and Parallelization","title":"Error and Parallelization","text":"In this section is possible to appreciate the error decrease increasing the order or the mesh refinement - while using the VMS stabilization. 2D Taylor-Green vortex case is used as benchmark case to assess the error analysis of the code. The domain is a square of size: [-0.5,0.5]x[-0.5,0.5], at Reynolds number 1600. The CFL is constant for each simulation, CFL=0.32. The time-step is compted as dt = CFL  (ordercdot N).","category":"page"},{"location":"Theory/Errors/","page":"Error and Parallelization","title":"Error and Parallelization","text":"(Image: TGV)","category":"page"},{"location":"Theory/Errors/","page":"Error and Parallelization","title":"Error and Parallelization","text":"(Image: TGV)","category":"page"},{"location":"Theory/Errors/#Parallelization","page":"Error and Parallelization","title":"Parallelization","text":"","category":"section"},{"location":"Theory/Errors/","page":"Error and Parallelization","title":"Error and Parallelization","text":"In this section is possible to appreciate the weak and strong scalability of the implementation of the code. The benchmark case is the 2D taylor Green, the time reported here are intended for each time-step. The order of the elements for this simulation is always 2, and the CFL constant at 0.32","category":"page"},{"location":"Theory/Errors/","page":"Error and Parallelization","title":"Error and Parallelization","text":" Preconditioner Linear Solver\nVelocity gamg gmres\nPressure gamg cg","category":"page"},{"location":"Theory/Errors/","page":"Error and Parallelization","title":"Error and Parallelization","text":"For parallelization is used MPI, and to solve the sparse and distribute numerical systems we use PETSc","category":"page"},{"location":"Theory/Errors/#Strong-Parallelization","page":"Error and Parallelization","title":"Strong Parallelization","text":"","category":"section"},{"location":"Theory/Errors/","page":"Error and Parallelization","title":"Error and Parallelization","text":"Strong scalability evaluates how efficiently a parallel code reduces execution time when the problem size remains fixed, but the number of processing units increases. There is a total of 400 elements on each side, leading to 160000 elements and 1920000 dofs in total. (Image: TGV)","category":"page"},{"location":"Theory/Errors/#Weak-Parallelization","page":"Error and Parallelization","title":"Weak Parallelization","text":"","category":"section"},{"location":"Theory/Errors/","page":"Error and Parallelization","title":"Error and Parallelization","text":"Weak scalability measures how well a parallel code maintains performance when the problem size is kept constant per processor, and the number of processors increases. On each processor there are 50x50 elements, the number of dofs is kept constant at approx 30K dfos/procs. (Image: TGV)","category":"page"},{"location":"Theory/FEMTheory/#Finite-Element-Method-(FEM)-for-Incompressible-Navier-Stokes-Equations","page":"FEM","title":"Finite Element Method (FEM) for Incompressible Navier-Stokes Equations","text":"","category":"section"},{"location":"Theory/FEMTheory/","page":"FEM","title":"FEM","text":"The Finite Element Method (FEM) is a widely-used numerical technique for solving partial differential equations (PDEs) that arise in engineering and physics. For the incompressible Navier-Stokes equations, FEM is particularly effective in handling complex geometries and boundary conditions. This section introduces the role of test functions in FEM, the formulation of velocity and pressure spaces, and discusses the issue of Q1/Q1 instabilities.","category":"page"},{"location":"Theory/FEMTheory/#Introduction-to-Test-Functions","page":"FEM","title":"Introduction to Test Functions","text":"","category":"section"},{"location":"Theory/FEMTheory/","page":"FEM","title":"FEM","text":"In FEM, the governing equations are reformulated in their weak form. This involves multiplying the equations by test functions and integrating over the computational domain. For the incompressible Navier-Stokes equations, let:","category":"page"},{"location":"Theory/FEMTheory/","page":"FEM","title":"FEM","text":"v: Test function for velocity, v in V, where V is the velocity test function space.\nq: Test function for pressure,  q in Q, where  Q is the pressure test function space.","category":"page"},{"location":"Theory/FEMTheory/","page":"FEM","title":"FEM","text":"The weak form of the equations is:","category":"page"},{"location":"Theory/FEMTheory/","page":"FEM","title":"FEM","text":"int_Omega  (  fracpartial upartial tcdot v + u cdotnabla (u) cdot v +nu nabla (u) nabla (v) - vcdot f )dOmega + int_Omega  ( nablacdot (u) cdot q  )dOmega ","category":"page"},{"location":"Theory/FEMTheory/#Elements-and-Instabilities","page":"FEM","title":"Elements and Instabilities","text":"","category":"section"},{"location":"Theory/FEMTheory/","page":"FEM","title":"FEM","text":"The Q1/Q1 element is a finite element pair where both velocity and pressure are approximated using bilinear shape functions (( Q1 ) functions) on quadrilateral elements. While computationally simple and efficient, this choice suffers from numerical instabilities due to a violation of the Ladyzhenskaya-Babu\\v{s}ka-Brezzi (LBB) or inf-sup condition.","category":"page"},{"location":"Theory/FEMTheory/","page":"FEM","title":"FEM","text":"The inf-sup condition ensures a stable coupling between velocity and pressure spaces. Q1/Q1 elements typically fail to satisfy this condition, leading to spurious pressure modes and oscillations in the solution. These instabilities manifest as:","category":"page"},{"location":"Theory/FEMTheory/","page":"FEM","title":"FEM","text":"Unphysical pressure fields with checkerboard patterns.\nPoor convergence of the numerical solution.","category":"page"},{"location":"Theory/FEMTheory/#Remedies-for-Q1/Q1-Instabilities","page":"FEM","title":"Remedies for Q1/Q1 Instabilities","text":"","category":"section"},{"location":"Theory/FEMTheory/","page":"FEM","title":"FEM","text":"Stabilization Techniques: Introduce stabilization methods like the Streamline Upwind Petrov-Galerkin (SUPG) method to regularize the pressure field.","category":"page"},{"location":"Tools/visualization/#Visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"Tools/visualization/","page":"Visualization","title":"Visualization","text":"In this section is explained how to visualize the results.","category":"page"},{"location":"Tools/visualization/#Using-Paraview","page":"Visualization","title":"Using Paraview","text":"","category":"section"},{"location":"Tools/visualization/","page":"Visualization","title":"Visualization","text":"ParaView allows to graphically visualize the results and open .vtu and .pvtu files. There are a lot of embedded and advanced tools.","category":"page"},{"location":"Tools/visualization/","page":"Visualization","title":"Visualization","text":"By default, no .vtu are created, to save disk space. Creating Log/PrintSim.txt allows to monitor the current state of the simulation creating .pvtu files. If you cancel the directory, or re-name the file, the code will stop creating .pvtu files, it a way to interact in-real-time with the application running.","category":"page"},{"location":"Tools/visualization/","page":"Visualization","title":"Visualization","text":"You can create a Paraview files collecting in sequence all the  .vtu to visualize them in temporal sequence. Use the provided api specifying the folder where your .vtu are stored.","category":"page"},{"location":"Tools/visualization/","page":"Visualization","title":"Visualization","text":"using SegregatedVMSSolver.CreateVtu\n\ncreate_vtu_file(\"Results_vtu/\")","category":"page"},{"location":"Tools/visualization/","page":"Visualization","title":"Visualization","text":"info: numeric info\nIt is suggested to use it at the beginning of the simulation to check the convergence of the simulation and the boundary conditions. It may consume a lot of storage space saving all time steps for 3D simulations. ","category":"page"},{"location":"Cases/examples/#Examples","page":"Intro","title":"Examples","text":"","category":"section"},{"location":"Cases/examples/","page":"Intro","title":"Intro","text":"In this section of the documentation you can find some examples explained. In the folder /examples of the repository you can find some examples to run in the REPL.","category":"page"},{"location":"Cases/examples/","page":"Intro","title":"Intro","text":"To run it in parallel, give it a look at ","category":"page"},{"location":"Cases/taylorgreen3D/#Taylor-Green-Vortex-3D","page":"Taylor Green 3D","title":"Taylor Green Vortex 3D","text":"","category":"section"},{"location":"Cases/taylorgreen3D/","page":"Taylor Green 3D","title":"Taylor Green 3D","text":"The Taylor-Green Vortex (TGV) is a canonical test case for the study of transition to turbulence and energy dissipation in incompressible flows. The flow is initialized in a cubic domain with periodic boundary conditions imposed on all sides. The domain extends from -pi to pi in each spatial direction (x, y, z).","category":"page"},{"location":"Cases/taylorgreen3D/","page":"Taylor Green 3D","title":"Taylor Green 3D","text":"The initial velocity components of the TGV in 3D are given by:","category":"page"},{"location":"Cases/taylorgreen3D/","page":"Taylor Green 3D","title":"Taylor Green 3D","text":"u(x y z 0) = U_0 cos(kx) sin(ky) sin(kz)","category":"page"},{"location":"Cases/taylorgreen3D/","page":"Taylor Green 3D","title":"Taylor Green 3D","text":"v(x y z 0) = -U_0 sin(kx) cos(ky) sin(kz)","category":"page"},{"location":"Cases/taylorgreen3D/","page":"Taylor Green 3D","title":"Taylor Green 3D","text":"w(x y z 0) = 0","category":"page"},{"location":"Cases/taylorgreen3D/","page":"Taylor Green 3D","title":"Taylor Green 3D","text":"where U_0 is the velocity amplitude, k is the wave number, and (x y z) are the spatial coordinates. In this case U_0=00 and k=1.","category":"page"},{"location":"Cases/taylorgreen3D/","page":"Taylor Green 3D","title":"Taylor Green 3D","text":"The corresponding initial pressure field is:","category":"page"},{"location":"Cases/taylorgreen3D/","page":"Taylor Green 3D","title":"Taylor Green 3D","text":"p(x y z 0) = fracU_0^216 left cos(2kx) + cos(2ky) right cos(2kz+2)","category":"page"},{"location":"Cases/taylorgreen3D/","page":"Taylor Green 3D","title":"Taylor Green 3D","text":"E(t) = frac12 Omega int_Omega boldsymbolu^2  dOmega","category":"page"},{"location":"Cases/taylorgreen3D/","page":"Taylor Green 3D","title":"Taylor Green 3D","text":"where boldsymbolu = (u v w) is the velocity vector, and Omega is the volume of the domain.","category":"page"},{"location":"Cases/taylorgreen3D/","page":"Taylor Green 3D","title":"Taylor Green 3D","text":"The rate of decay of kinetic energy is linked to enstrophy mathcalE(t), which is defined as:","category":"page"},{"location":"Cases/taylorgreen3D/","page":"Taylor Green 3D","title":"Taylor Green 3D","text":"mathcalE(t) = frac1Omega int_Omega boldsymbolomega^2  dOmega","category":"page"},{"location":"Cases/taylorgreen3D/","page":"Taylor Green 3D","title":"Taylor Green 3D","text":"where boldsymbolomega = nabla times boldsymbolu is the vorticity vector. For incompressible flows, the decay rate of kinetic energy is governed by viscous dissipation:","category":"page"},{"location":"Cases/taylorgreen3D/","page":"Taylor Green 3D","title":"Taylor Green 3D","text":"fracdE(t)dt = -nu mathcalE(t)","category":"page"},{"location":"Cases/taylorgreen3D/","page":"Taylor Green 3D","title":"Taylor Green 3D","text":"where nu is the kinematic viscosity of the fluid. This relationship demonstrates that the rate at which kinetic energy decreases is directly proportional to the enstrophy, which quantifies the rotational intensity of the flow.","category":"page"},{"location":"Cases/taylorgreen3D/#Simulation-File","page":"Taylor Green 3D","title":"Simulation File","text":"","category":"section"},{"location":"Cases/taylorgreen3D/","page":"Taylor Green 3D","title":"Taylor Green 3D","text":"using PartitionedArrays\nusing SegregatedVMSSolver\nusing SegregatedVMSSolver.ParametersDef\nusing SegregatedVMSSolver.SolverOptions\nusing MPI\n\nt0 =0.0\ndt = 0.01\ntF = 20\nvortex_diameter = 1.0\nN = 64\nRe = 1600\nD = 3\n\nbackend = with_mpi\nrank_partition = (4,4,4)\norder = 2\n\nsolver_options = petsc_options(; vel_ksp=\"gmres\", vel_pc=\"gamg\", pres_ksp = \"cg\", pres_pc = \"asm\")\nsprob = StabilizedProblem(VMS(order))\ntimep = TimeParameters(t0=t0,dt=dt,tF=tF)\n\nphysicalp = PhysicalParameters(Re=Re,c=vortex_diameter)\nsolverp = SolverParameters(matrix_freq_update = 5, Number_Skip_Expansion=10e6, M = 40,\npetsc_options = solver_options)\nexportp = ExportParameters(printinitial=true, printmodel=true, \nvtu_export = [\"uh\",\"ph\"], extra_export=[\"KineticEnergy\", \"Enstrophy\"])\n\n\nmeshp= MeshParameters(rank_partition,D;N=N,L= pi*vortex_diameter)\nsimparams = SimulationParameters(timep,physicalp,solverp,exportp)\n\nbc_tgv = Periodic(meshp,physicalp ) \n\nmcase = TaylorGreen(bc_tgv, meshp,simparams,sprob)\n\nSegregatedVMSSolver.solve(mcase,backend)","category":"page"},{"location":"Cases/taylorgreen3D/","page":"Taylor Green 3D","title":"Taylor Green 3D","text":"at each time-step, a new line on a .csv file will be written with: timestep-KineticEnergy-Enstrophy. You can use this file to compare with available DNS results.","category":"page"},{"location":"Cases/taylorgreen3D/#Results","page":"Taylor Green 3D","title":"Results","text":"","category":"section"},{"location":"Cases/taylorgreen3D/","page":"Taylor Green 3D","title":"Taylor Green 3D","text":"The Linearized and Segregated VariationalMultiScale method has been validated with test case. The time-step is constant Delta t =001s, the matrices are re-computed every 5 time-steps. The Reynolds number is 1600, it is used to compute the viscosity: nu = U_0 k  Re. Order of interpolation of velocity and pressure is the same. The benchmark is the DNS result. The flow patterns generated by the Taylor-Green vortex are quite complex. The resolution of the most complex case tested: 64x64x64 Q2Q2, takes 40 hours on a 64CORE machine.","category":"page"},{"location":"Cases/taylorgreen3D/","page":"Taylor Green 3D","title":"Taylor Green 3D","text":"We note that the kinetic energy decay does not match that of the reference for Q1 elements, there is significant numerical dissipation since the enstrophy does not match the kinetic energy decay. (Image: TGV)","category":"page"},{"location":"Cases/taylorgreen3D/","page":"Taylor Green 3D","title":"Taylor Green 3D","text":"Increasing the order from Q1 to Q2 yield the following results which are better. (Image: TGV)","category":"page"},{"location":"Cases/taylorgreen3D/","page":"Taylor Green 3D","title":"Taylor Green 3D","text":"(Image: TGV)","category":"page"},{"location":"sim_params/#Simulation-Parameters","page":"Simulation Parameters","title":"Simulation Parameters","text":"","category":"section"},{"location":"sim_params/","page":"Simulation Parameters","title":"Simulation Parameters","text":"The simualtion parameters are used to solve the incompressible Navier-Stokes problem.","category":"page"},{"location":"sim_params/","page":"Simulation Parameters","title":"Simulation Parameters","text":"The Simulation Parameters are defined in src/Commons/ParametersDef/StabilizationStruct.jl, where the default values are also provided.","category":"page"},{"location":"sim_params/","page":"Simulation Parameters","title":"Simulation Parameters","text":"using SegregatedVMSSolver\nusing SegregatedVMSSolver.ParametersDef\n\nsprob = StabilizedProblem()","category":"page"},{"location":"sim_params/","page":"Simulation Parameters","title":"Simulation Parameters","text":"The user is creating a StabilizedProblem using the default options. It is possible to specify:","category":"page"},{"location":"sim_params/","page":"Simulation Parameters","title":"Simulation Parameters","text":"method: VMS() or SUPG() where also the order of elements can be specified\ncoeff_method: TensorFormulation(), ScalarFormulation(). Stabilization coefficients r and Ci can be provided.\nskew: enable a skew-symmetric formulation","category":"page"},{"location":"sim_params/","page":"Simulation Parameters","title":"Simulation Parameters","text":"sprob = StabilizedProblem(method=SUPG(1), coeff_method=TensorFormulation(Ci=[2,16], r=2), skew=true)","category":"page"},{"location":"sim_params/","page":"Simulation Parameters","title":"Simulation Parameters","text":"In this example the StabilizedProblem is using a SUPG resolution, using first order elements, a method to compute the coeffients based on the tensor formulation, with the supplied coefficients and a skew symmetric formulation of the conservation equations.","category":"page"},{"location":"api_info/#Index","page":"API information","title":"Index","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"CurrentModule = SegregatedVMSSolver.ParametersDef","category":"page"},{"location":"api_info/#ParametersDef","page":"API information","title":"ParametersDef","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"Modules = [ParametersDef,]","category":"page"},{"location":"api_info/#SegregatedVMSSolver.ParametersDef.analytical_solution-NTuple{5, Any}","page":"API information","title":"SegregatedVMSSolver.ParametersDef.analytical_solution","text":"analytical_solution(diameter::Int64, Vs::Float64, Ua::Float64, Va::Float64, ν::Float64)\n\nIt provides the anlytical solution for the Taylor Green Vortex case. Solution for the 2D periodic case\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ParametersDef.compute_fluctuation-Tuple{Any, Any, Any}","page":"API information","title":"SegregatedVMSSolver.ParametersDef.compute_fluctuation","text":"compute_fluctuation(x,t, simcase::SimulationCase)\n\nFor the point x, at the time t it computes the velocity fluctuations in all the direction. Each time the time t is increased the Eddy are convected. The time informations are coded in the VirtualBox.\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ParametersDef.create_new_case-Tuple{Symbol}","page":"API information","title":"SegregatedVMSSolver.ParametersDef.create_new_case","text":"create_new_case(case::Symbol)\n\nIt creates a new case, named case. It is useful to add new simulation cases in a high level way.\n\n\n\n\n\n","category":"method"},{"location":"api_info/","page":"API information","title":"API information","text":"CurrentModule = SegregatedVMSSolver.CreateProblem","category":"page"},{"location":"api_info/#CreateProblem","page":"API information","title":"CreateProblem","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"Modules = [CreateProblem,]","category":"page"},{"location":"api_info/#SegregatedVMSSolver.CreateProblem.add_SEM_tag!-Tuple{Any, Float64}","page":"API information","title":"SegregatedVMSSolver.CreateProblem.add_SEM_tag!","text":"add the SEM tag to the nodes in front of the airfoil. c: chord of the airfoil, the points are on a circle at 1 chord of distance from the leading edge.  set a_tol for selecting only one lines of points, it depends on how fine the mesh is. \n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.CreateProblem.add_centre_tag!-Tuple{Any, Gridap.TensorValues.VectorValue}","page":"API information","title":"SegregatedVMSSolver.CreateProblem.add_centre_tag!","text":"add_centre_tag!(model, tag_coordinate::Point)\n\nIt creates the centre tag at the tag_coordinate (Point); if mesh extremely fine the tolrances have to be smaller (unlikely)\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.CreateProblem.add_new_tag!-Tuple{Any, Gridap.TensorValues.VectorValue, String}","page":"API information","title":"SegregatedVMSSolver.CreateProblem.add_new_tag!","text":"add_new_tag!(model, tag_coordinate::Point, tagname::String)\n\nIt add a new tag named tagname at the specified tag_coordinates    \n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.CreateProblem.create_initial_conditions-Tuple{SegregatedVMSSolver.ParametersDef.VelocityBoundaryCase, Dict{Symbol, Any}}","page":"API information","title":"SegregatedVMSSolver.CreateProblem.create_initial_conditions","text":"create_initial_conditions(simcase::SimulationCase)\n\nIt creates the initial conditions for velocity and pressure. If restart is true then the velocity and the pressure field are interpoled on the specified DataFrame.  \n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.CreateProblem.create_new_tag!-Tuple{GridapDistributed.DistributedDiscreteModel, String, Function}","page":"API information","title":"SegregatedVMSSolver.CreateProblem.create_new_tag!","text":"create_new_tag!(model::GridapDistributed.DistributedDiscreteModel, tagname::String, is_tag::Function)\n\nIt creates the centre tag at the tag_coordinate (Point); if mesh extremely fine the tolrances have to be smaller (unlikely)\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.CreateProblem.create_search_tree-Tuple{DataFrames.DataFrame}","page":"API information","title":"SegregatedVMSSolver.CreateProblem.create_search_tree","text":"create_search_tree(restart_df::DataFrame)\n\nCreate a BruteTree from the NearestNeighbors.jl package taking the coordinates points as input\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.CreateProblem.print_model-Tuple{Any, SegregatedVMSSolver.ParametersDef.SimulationCase}","page":"API information","title":"SegregatedVMSSolver.CreateProblem.print_model","text":"print_model(model,simcase::SimulationCase)\n\nIt prints the model mesh\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.CreateProblem.restart_ph_field-Tuple{Any, DataFrames.DataFrame}","page":"API information","title":"SegregatedVMSSolver.CreateProblem.restart_ph_field","text":"restart_ph_field(simcase::VelocityBoundary,tree)\n\nIt provides a suitable function which gives for each point the specified pressure in restart_file. It is used as initial condition for restarting a simulation at a specific time step.\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.CreateProblem.restart_uh_field-Tuple{Int64, Any, DataFrames.DataFrame}","page":"API information","title":"SegregatedVMSSolver.CreateProblem.restart_uh_field","text":"restart_uh_field(D::Int64,tree,restart_df::DataFrame)\n\nIt provides a suitable function which gives for each point the specified velocity in restart_file. It is used as initial condition for restarting a simulation at a specific time step.\n\n\n\n\n\n","category":"method"},{"location":"api_info/","page":"API information","title":"API information","text":"CurrentModule = SegregatedVMSSolver.Equations","category":"page"},{"location":"api_info/#Equations","page":"API information","title":"Equations","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"Modules = [Equations,]","category":"page"},{"location":"api_info/#SegregatedVMSSolver.Equations.G_params-Tuple{GridapDistributed.DistributedTriangulation, Int64}","page":"API information","title":"SegregatedVMSSolver.Equations.G_params","text":"G_params(Ω::Triangulation, D)\n\nCompute the tensor G and the values GG and gg according to the VMS formulation proposed by [6] \n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.Equations.cconv-Tuple{Any, Any}","page":"API information","title":"SegregatedVMSSolver.Equations.cconv","text":"cconv(uadv, ∇u) \n\nWrapper for the convective term   u(nabla u)  \n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.Equations.compute_G-Tuple{Gridap.Geometry.BodyFittedTriangulation, Int64}","page":"API information","title":"SegregatedVMSSolver.Equations.compute_G","text":"compute_G(trian::Gridap.Geometry.BodyFittedTriangulation, D::Int64)\n\nCompute G (AbstractArray of TensorValues)\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.Equations.compute_GG-Tuple{Gridap.Geometry.BodyFittedTriangulation, Int64}","page":"API information","title":"SegregatedVMSSolver.Equations.compute_GG","text":"compute_GG(trian::Gridap.Geometry.BodyFittedTriangulation, params)\n\nCompute GG \n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.Equations.compute_d-Tuple{Gridap.Geometry.BodyFittedTriangulation, Int64}","page":"API information","title":"SegregatedVMSSolver.Equations.compute_d","text":"compute_d(trian::Gridap.Geometry.BodyFittedTriangulation, D::Int64) #trian == Ω\n\nThe inverse of the cell-map-field. It is evaluted in the middle of the refernce domain.\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.Equations.compute_gg-Tuple{Gridap.Geometry.BodyFittedTriangulation, Int64}","page":"API information","title":"SegregatedVMSSolver.Equations.compute_gg","text":"compute_GG(trian::Gridap.Geometry.BodyFittedTriangulation, D::Int64)\n\nCompute gg \n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.Equations.continuity_stabilization-Tuple{Any, SegregatedVMSSolver.ParametersDef.ScalarStabilization, SegregatedVMSSolver.ParametersDef.SimulationCase}","page":"API information","title":"SegregatedVMSSolver.Equations.continuity_stabilization","text":"continuity_stabilization(uu, stab_coeff::ScalarStabilization,simcase::SimulationCase )\n\nStabilization parameters continuity equation Janssens, B. (2014). Numerical modeling and experimental investigation of ﬁne particle coagulation and dispersion in dilute ﬂows.\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.Equations.continuity_stabilization-Tuple{Any, SegregatedVMSSolver.ParametersDef.TensorStabilization, SegregatedVMSSolver.ParametersDef.SimulationCase}","page":"API information","title":"SegregatedVMSSolver.Equations.continuity_stabilization","text":"continuity_stabilization(uu, stab_coeff::TensorStabilization,simcase::SimulationCase )\n\nStabilization parameter continuity Bazilevs, Y., Calo, V. M., Cottrell, J. A., Hughes, T. J. R., Reali, A., & Scovazzi, G. (2007). Variational multiscale residual-based turbulence modeling for large eddy simulation of incompressible flows. Computer Methods in Applied Mechanics and Engineering, 197(1–4), 173–201. https://doi.org/10.1016/j.cma.2007.07.016\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.Equations.h_param-Tuple{Gridap.Geometry.Triangulation, Int64}","page":"API information","title":"SegregatedVMSSolver.Equations.h_param","text":"h_param(Ω::Triangulation, D::Int64)\n\nFor a given triangulation Ω it computes the cell size Area^12 D=2 Volume^13 D=3\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.Equations.momentum_stabilization-Tuple{Any, SegregatedVMSSolver.ParametersDef.ScalarStabilization, SegregatedVMSSolver.ParametersDef.SimulationCase}","page":"API information","title":"SegregatedVMSSolver.Equations.momentum_stabilization","text":"momentum_stabilization(uu, stab_coeff::ScalarStabilization,simcase::SimulationCase )\n\nStabilization parameters momentum equation Janssens, B. (2014). Numerical modeling and experimental investigation of ﬁne particle coagulation and dispersion in dilute ﬂows.\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.Equations.momentum_stabilization-Tuple{Any, SegregatedVMSSolver.ParametersDef.TensorStabilization, SegregatedVMSSolver.ParametersDef.SimulationCase}","page":"API information","title":"SegregatedVMSSolver.Equations.momentum_stabilization","text":"momentum_stabilization(uu, stab_coeff::TensorStabilization,simcase::SimulationCase )\n\nStabilization parameter momentum stabilization Bazilevs, Y., Calo, V. M., Cottrell, J. A., Hughes, T. J. R., Reali, A., & Scovazzi, G. (2007). Variational multiscale residual-based turbulence modeling for large eddy simulation of incompressible flows. Computer Methods in Applied Mechanics and Engineering, 197(1–4), 173–201. https://doi.org/10.1016/j.cma.2007.07.016\n\n\n\n\n\n","category":"method"},{"location":"api_info/","page":"API information","title":"API information","text":"CurrentModule = SegregatedVMSSolver.MatrixCreation","category":"page"},{"location":"api_info/#MatrixCreation","page":"API information","title":"MatrixCreation","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"Modules   = [MatrixCreation]","category":"page"},{"location":"api_info/#SegregatedVMSSolver.MatrixCreation.allocate_Mat_inv_ML-Tuple{PartitionedArrays.PSparseMatrix}","page":"API information","title":"SegregatedVMSSolver.MatrixCreation.allocate_Mat_inv_ML","text":"allocate_Mat_inv_ML(Mat_ML::PSparseMatrix)\n\nIt allocates a zero vector where to store the inverse of the lumped matrix\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.MatrixCreation.initialize_vectors-Tuple{Tuple, Any, Any}","page":"API information","title":"SegregatedVMSSolver.MatrixCreation.initialize_vectors","text":"initialize_vectors(matrices::Tuple,uh0,ph0)\n\nIt initializes vectors where velocity, pressure, acceleration and all the increments will be stored.\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.MatrixCreation.inv_lump_vel_mass!-Tuple{PartitionedArrays.PVector, PartitionedArrays.PSparseMatrix}","page":"API information","title":"SegregatedVMSSolver.MatrixCreation.inv_lump_vel_mass!","text":"inv_lump_vel_mass!(Mat_inv_ML::PVector,Mat_ML::PSparseMatrix)\n\nIt computes the lumped matrix, takes the inverse of the diagonal elements.\n\n\n\n\n\n","category":"method"},{"location":"api_info/","page":"API information","title":"API information","text":"CurrentModule = SegregatedVMSSolver.SolverOptions","category":"page"},{"location":"api_info/#SolverOptions","page":"API information","title":"SolverOptions","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"Modules   = [SolverOptions]","category":"page"},{"location":"api_info/#SegregatedVMSSolver.SolverOptions.create_PETSc_setup-Tuple{AbstractMatrix, Function}","page":"API information","title":"SegregatedVMSSolver.SolverOptions.create_PETSc_setup","text":"create_PETSc_setup(M::AbstractMatrix,ksp_setup::Function)\n\nWrapper for creating PETSc symbolic and numeric setup for GridapPETSc  \n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.SolverOptions.petsc_options-Tuple{}","page":"API information","title":"SegregatedVMSSolver.SolverOptions.petsc_options","text":"petsc_options(; vel_ksp=\"gmres\", vel_pc=\"gamg\", pres_ksp = \"cg\", pres_pc = \"gamg\")\n\nIt provides the command-line for GridapPETSc to solve the segregated linear systems\n\n\n\n\n\n","category":"method"},{"location":"api_info/","page":"API information","title":"API information","text":"CurrentModule = SegregatedVMSSolver.VectorsOperations","category":"page"},{"location":"api_info/#VectorsOperations","page":"API information","title":"VectorsOperations","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"Modules   = [VectorsOperations]","category":"page"},{"location":"api_info/#SegregatedVMSSolver.VectorsOperations.create_ũ_vector-Tuple{AbstractVector}","page":"API information","title":"SegregatedVMSSolver.VectorsOperations.create_ũ_vector","text":"create_ũ_vector(zfv1::AbstractVector)\n\nIt allocates the vector to keep in memory the velocity field up to previous 4 time steps\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.VectorsOperations.set_zeros!-Tuple{PartitionedArrays.DebugArray}","page":"API information","title":"SegregatedVMSSolver.VectorsOperations.set_zeros!","text":"set_zeros!(fields::DebugArray)\n\nSet zeros as free values for a field\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.VectorsOperations.update_ũ-Tuple{Vector}","page":"API information","title":"SegregatedVMSSolver.VectorsOperations.update_ũ","text":"updateũ(ũvec::Vector)\n\nIt uses the Taylor expansion proposed by [7]\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.VectorsOperations.update_ũ_vector!-Tuple{Vector, AbstractVector}","page":"API information","title":"SegregatedVMSSolver.VectorsOperations.update_ũ_vector!","text":"update_ũ_vector!(ũ_vec::Vector, uh_new::AbstractVector)\n\nIt updates the vector which stores the values of velocity at previous time steps.\n\n\n\n\n\n","category":"method"},{"location":"api_info/","page":"API information","title":"API information","text":"CurrentModule = SegregatedVMSSolver.ExportUtility","category":"page"},{"location":"api_info/#ExportUtility","page":"API information","title":"ExportUtility","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"Modules   = [ExportUtility]","category":"page"},{"location":"api_info/#SegregatedVMSSolver.ExportUtility.compute_enstrophy_ek-Tuple{Any, Dict{Symbol, Any}, Tuple, Float64}","page":"API information","title":"SegregatedVMSSolver.ExportUtility.compute_enstrophy_ek","text":"compute_enstrophy_ek(simcase, params::Dict{Symbol,Any}, fields::Tuple)\n\nCompute enstrophy and Kinetic Energy - not normalized with volume.\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ExportUtility.compute_error-Tuple{TaylorGreen{Periodic}, Dict{Symbol, Any}, Float64, Tuple}","page":"API information","title":"SegregatedVMSSolver.ExportUtility.compute_error","text":"compute_error(params::Dict{Symbol,Any}, simcase::TaylorGreen{Periodic},  tn::Float64, fields::Tuple)\n\nCompute L2 error norm for velocity and pressure for TGV2D case. https://doi.org/10.1016/j.enganabound.2020.12.018\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ExportUtility.conv_to_df-Tuple{Vector{Float64}}","page":"API information","title":"SegregatedVMSSolver.ExportUtility.conv_to_df","text":"conv_to_df(vv::Vector)\n\nConvert a Vector{Float64} to a DataFrame. It is used for export pressure field.\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ExportUtility.conv_to_df-Tuple{Vector}","page":"API information","title":"SegregatedVMSSolver.ExportUtility.conv_to_df","text":"conv_to_df(vv::Vector)\n\nConvert a Vector{Vector} to a DataFrame. It is used for export nodes, normals.\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ExportUtility.create_export_tags!-Tuple{Dict{Symbol, Any}, Vector}","page":"API information","title":"SegregatedVMSSolver.ExportUtility.create_export_tags!","text":"create_export_tags!(params::Dict{Symbol,Any})\n\nFor each ´nametags´ it creates the ´exporttags´ dictionary\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ExportUtility.export_fields-Tuple{Dict{Symbol, Any}, Vector, Float64, Any, Any}","page":"API information","title":"SegregatedVMSSolver.ExportUtility.export_fields","text":"export_fields(params::Dict{Symbol,Any}, fieldexport::Vector, tt::Float64, uh0, ph0)\n\nExport pressure and friction (not multiplied by viscosity) - airfoil simulations oriented\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ExportUtility.print_on_request-Tuple{String}","page":"API information","title":"SegregatedVMSSolver.ExportUtility.print_on_request","text":"print_on_request(log_dir::String)\n\nIf in the directory log_dir exists and there is the PrintSim.txt file return true. If true is printing simulations results in Paraview format (.vtu and .pvtu). \n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ExportUtility.write_to_csv-Tuple{String, Vector{Float64}, Vector{String}, Any}","page":"API information","title":"SegregatedVMSSolver.ExportUtility.write_to_csv","text":"write_to_csv(file_path::String, data::Vector{Vector{Any}}, parts)\n\nWrite Results on CSV file\n\n\n\n\n\n","category":"method"},{"location":"api_info/","page":"API information","title":"API information","text":"CurrentModule = SegregatedVMSSolver.SolveProblem","category":"page"},{"location":"api_info/#SolveProblem","page":"API information","title":"SolveProblem","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"Modules   = [SolveProblem]","category":"page"},{"location":"api_info/#SegregatedVMSSolver.SolveProblem.solve_case-Tuple{Dict{Symbol, Any}, SegregatedVMSSolver.ParametersDef.SimulationCase}","page":"API information","title":"SegregatedVMSSolver.SolveProblem.solve_case","text":"solve_case(params::Dict{Symbol,Any})\n\nIt solves iteratively the velocity and pressure system.\n\n\n\n\n\n","category":"method"},{"location":"api_info/","page":"API information","title":"API information","text":"CurrentModule = SegregatedVMSSolver.Interfaces","category":"page"},{"location":"api_info/#Interfaces","page":"API information","title":"Interfaces","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"Modules = [ Interfaces,]","category":"page"},{"location":"api_info/#SyntheticEddyMethod.VirtualBox-Tuple{Tuple{Real, Real}, Tuple{Real, Real}}","page":"API information","title":"SyntheticEddyMethod.VirtualBox","text":"VirtualBox(ylims::Tuple{Real,Real}, zlims::Tuple{Real,Real} ; σ=0.1)\n\nUtility to create VirtualBox, specifing the ylims of the inlet, the zlims for the virtual plane, and the σ eddy dimension. Refer to the original documentation of the package SynteticEddyMethod for more info, and specifing more advanced settings\n\n\n\n\n\n","category":"method"},{"location":"api_info/#Utils","page":"API information","title":"Utils","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"CurrentModule = SegregatedVMSSolver.ReadAirfoilResults","category":"page"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"Modules = [ ReadAirfoilResults,]","category":"page"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.XYPlane","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.XYPlane","text":"XYPlane\n\nGive a zp coordinate, it gives the indexes of the points in that XY plane\n\n\n\n\n\n","category":"type"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.ZProbe","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.ZProbe","text":"ZProbe\n\nGive a 2D point coordinate xp, yp, it gived the idx of the points aligned in the z direction\n\n\n\n\n\n","category":"type"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.average_3D_field-Tuple{SegregatedVMSSolver.ReadAirfoilResults.GeometryNodes{SegregatedVMSSolver.ReadAirfoilResults.D3}, DataFrames.DataFrame}","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.average_3D_field","text":"average_3D_field(nodes::GeometryNodes{D3}, df_field::DataFrame)\n\nIt is averaging the dataframes value over the points aligned in the z direction\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.average_3D_field-Tuple{String, String, SegregatedVMSSolver.ReadAirfoilResults.GeometryNodes}","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.average_3D_field","text":"average_3D_field(path::String, field_name::String; offset=1, offend = 0, step::Int64=1, tagname=\"airfoil\")\n\nIt provides Array{DataFrame}, where each element is a DataFrame at a single time step of the average in z direction.\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.compute_CL_CD-Tuple{SegregatedVMSSolver.ReadAirfoilResults.GeometryNodes, Vararg{Any, 4}}","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.compute_CL_CD","text":"compute_CL_CD(top_nodesx,bottom_nodesx,top_nodesy,bottom_nodesy,cp_top,cp_bottom,\nfriction_top,friction_bottom; chord = 1.0)\n\nIt computes lift and drag coefficients\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.compute_CL_CD_separation_time-Tuple{SegregatedVMSSolver.ReadAirfoilResults.GeometryNodes, Any, Float64}","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.compute_CL_CD_separation_time","text":"compute_CL_CD(top_nodesx,bottom_nodesx,top_nodesy,bottom_nodesy,cp_top,cp_bottom,\nfriction_top,friction_bottom; chord = 1.0)\n\nIt computes lift and drag coefficients\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.compute_PSD-Tuple{Array, Vector{Float64}}","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.compute_PSD","text":"compute_PSD(Vel::Array, tn::Vector{Float64})\n\nIt computes the PSD of the TKE. Vel is the result obtained through read_fluctuations. The spectras are averaged in the Z direction \n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.compute_plane_tke-Tuple{String}","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.compute_plane_tke","text":"compute_plane_tke(res_path::String;tagname=\"topairfoil\", offset=1,offend=-1, zp=[0.1])\n\nIt computes the TKE for each point in the plane with Z=Zp.\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.compute_scatter_interp-Tuple{Any, Vector{Float64}, Float64}","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.compute_scatter_interp","text":"compute_scatter_interp(res_path, velocity::Vector{Float64} ,zp::Float64; tagname=\"topairfoil\", ylims=[-0.018,0.15], xlims=[0.5,1.0])\n\nIn res_path is reading the nodes file associated with the tagname. It computes the interpolation of the values in velocity on nodes of plane in zp. NearestNeighbor() algorithm is used.\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.extract_Cf-Tuple{SegregatedVMSSolver.ReadAirfoilResults.GeometryNodes, DataFrames.DataFrame, Float64}","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.extract_Cf","text":"extract_Cf(nodes::GeometryNodes, Friction::DataFrame; u0::Float64, μ::Float64, rho::Float64)\n\nFor a given set of nodes and Ph dataframe, it provides the friction coefficient for top and bottom\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.extract_Cp-Tuple{SegregatedVMSSolver.ReadAirfoilResults.GeometryNodes, DataFrames.DataFrame}","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.extract_Cp","text":"extract_Cp(nodes::GeometryNodes, Ph::DataFrame ; u0::Float64, rho::Float64)\n\nFor a given set of nodes and Ph dataframe, it provides the pressure coefficient for top and bottom\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.get_idx_sort_reduct-Tuple{String, String, Int64, Int64}","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.get_idx_sort_reduct","text":"get_idx_sort_reduct(res_path::String,tagname::String,offset::Int64,offend::Int64)\n\nIn res_path directory, for the boundary tagname, it provides the sorted file indexes\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.get_nodes-Tuple{String}","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.get_nodes","text":"get_nodes(path::String)\n\nIt provides a DataFrame with the nodes of the Airfoil boundary\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.get_normals-Tuple{String}","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.get_normals","text":"get_nodes(path::String)\n\nIt provides a DataFrame with the normals vectors at the surface of the Airfoil boundary    \n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.read_fluctuations-Tuple{String, Vector{Float64}}","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.read_fluctuations","text":"read_fluctuations(res_path::String, xpyp::Vector{Float64};tagname=\"topairfoil\", offset=1,offend=-1)\n\nIt is reading the results in res_path, for all the points aligned in Z direction of coordinates xpyp.  It provides the ZProbe which has the information of the actual nodes used. Vel_Mat is a dense matrix: Time x Points x Velocity Components (3) offset and offend can be used to skip intial and final files (avoiding OutOfMemory() error)\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.ReadAirfoilResults.time_space_average_field-Tuple{String, String, SegregatedVMSSolver.ReadAirfoilResults.GeometryNodes}","page":"API information","title":"SegregatedVMSSolver.ReadAirfoilResults.time_space_average_field","text":"time_space_average_field(path::String, field_name::String, nodes::GeometryNodes; offset=1, offend = 0, step::Int64=1, tagname=\"airfoil\")\n\nIt computes a time and span-average for a specific field. \n\n\n\n\n\n","category":"method"},{"location":"api_info/","page":"API information","title":"API information","text":"CurrentModule = SegregatedVMSSolver.WallDistance","category":"page"},{"location":"api_info/#SegregatedVMSSolver.WallDistance","page":"API information","title":"SegregatedVMSSolver.WallDistance","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"Modules = [ WallDistance,]","category":"page"},{"location":"api_info/#SegregatedVMSSolver.WallDistance.boundary_layer_height-Tuple{Real, Float64}","page":"API information","title":"SegregatedVMSSolver.WallDistance.boundary_layer_height","text":"boundary_layer_height(Re::Real, L::Float64)\n\nFrom Reynolds and characteristic dimension extimates the boundary layer height\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.WallDistance.boundary_layer_quadratic_profile-Tuple{Any, Float64, Real}","page":"API information","title":"SegregatedVMSSolver.WallDistance.boundary_layer_quadratic_profile","text":"boundary_layer_quadratic_profile(x, δ99::Float64, u_in::Real)\n\nParabolic approximation for boundary layer growth\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.WallDistance.get_initial_conditions-Tuple{String, Float64, Real, Any}","page":"API information","title":"SegregatedVMSSolver.WallDistance.get_initial_conditions","text":"getinitialconditions(meshfile::String, uin::Float64, Re::Real, walltag; chord::Float64=1.0, D::Int64=2, p::Int64=6)\n\nIt runs Picard iterations of the p-Poisson problem up to p=6 with relaxation factor of 0.5. It is require p>3 It creates the .vtu file with the boundary layer initialization and also the .csv file which can be used to start a simulation over an airfoil. It return a dataframe where for each nodes are provided the coordinates and the velocity vector components.\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.WallDistance.intialize_picard_iteration-NTuple{4, Any}","page":"API information","title":"SegregatedVMSSolver.WallDistance.intialize_picard_iteration","text":"intialize_picard_iteration(solver, Vg, V0, dΩ)\n\nSolve the p poisson for p=1\n\n\n\n\n\n","category":"method"},{"location":"api_info/#SegregatedVMSSolver.WallDistance.run_picard_iteration-Tuple{Any, Any, Any, Any, Any, Int64, Float64}","page":"API information","title":"SegregatedVMSSolver.WallDistance.run_picard_iteration","text":"run_picard_iteration(solver, Vg, V0, dΩ, uh_adv, p, γ)\n\nSolve the linearized p-Poisson. uh_adv is the solution at the previous iteration. γ is the relaxation parameter.\n\n\n\n\n\n","category":"method"},{"location":"Tools/post_proc/#Post-Processing","page":"Post Processing","title":"Post Processing","text":"","category":"section"},{"location":"Tools/post_proc/","page":"Post Processing","title":"Post Processing","text":"In this section is explained how to visualize the results and use the integrated post processing api for studying airfoils. All the results are saved in the folder /Results. ","category":"page"},{"location":"Tools/post_proc/#Using-Paraview","page":"Post Processing","title":"Using Paraview","text":"","category":"section"},{"location":"Tools/post_proc/","page":"Post Processing","title":"Post Processing","text":"ParaView which allows to graphically visualize the results and open .vtu and .pvtu files. There are a lot of embedded and advanced tools.","category":"page"},{"location":"Tools/post_proc/","page":"Post Processing","title":"Post Processing","text":"You can create a Paraview files collecting in sequence all the  .vtu to visualize them in temporal sequence. Use the provided api specifing the folder where your .vtu are stored. ´´´julia using SegregatedVMSSolver.CreateVtu","category":"page"},{"location":"Tools/post_proc/","page":"Post Processing","title":"Post Processing","text":"createvtufile(\"Results_vtu/\") ´´´","category":"page"},{"location":"Tools/post_proc/","page":"Post Processing","title":"Post Processing","text":"info: numeric info\nCreating Log/PrintSim.txt allows to monitor the current state of the simulation creating .pvtu files. It is suggested to use it at the beginning of the simulation to check the convergence of the simulation and the boundary conditions. It may consume a lot of storage space saving all time steps for 3D simulations. ","category":"page"},{"location":"Tools/post_proc/#Using-Integrated-API","page":"Post Processing","title":"Using Integrated API","text":"","category":"section"},{"location":"Tools/post_proc/","page":"Post Processing","title":"Post Processing","text":"A specific module ReadAirfoilResults has been develop. While running an Airfoil simulation the code automatically saves the results - for pressure and velocity normal gradient - just for the nodes that are part of the airfoil boundary. ","category":"page"},{"location":"Tools/post_proc/","page":"Post Processing","title":"Post Processing","text":"Use the ReadAirfoilResults module","category":"page"},{"location":"Tools/post_proc/","page":"Post Processing","title":"Post Processing","text":"using SegregatedVMSSolver\nusing SegregatedVMSSolver.ReadAirfoilResults","category":"page"},{"location":"Tools/post_proc/","page":"Post Processing","title":"Post Processing","text":"Specify the path where the .csv files with the results are stored.  Specify also the geometrical and physical parameters","category":"page"},{"location":"Tools/post_proc/","page":"Post Processing","title":"Post Processing","text":"res_path = \"Results/\"\nRe = 500_000\nu0 = 1.0\nc = 1.0\nrho = 1.0\nμ = u0*c*rho/Re\nα = 1.0","category":"page"},{"location":"Tools/post_proc/","page":"Post Processing","title":"Post Processing","text":"Get the nodes and normals","category":"page"},{"location":"Tools/post_proc/","page":"Post Processing","title":"Post Processing","text":"nodes, normals = get_geometry_info(res_path;α=α)","category":"page"},{"location":"Tools/post_proc/","page":"Post Processing","title":"Post Processing","text":"You can get the average - in time and spanwise direction - of velocity and friction field. It is possible to specify the number of time-step that you want to skip at the beginning of the averaging using the keyword offset. It allows to avoid averaging also the initils time-steps where the solution is still evolving.","category":"page"},{"location":"Tools/post_proc/","page":"Post Processing","title":"Post Processing","text":"Ph = time_space_average_field(res_path, \"ph\", nodes)\nVelocity = time_space_average_field(res_path, \"uh\", nodes)\nFriction = time_space_average_field(res_path, \"friction\", nodes)","category":"page"},{"location":"Tools/post_proc/","page":"Post Processing","title":"Post Processing","text":"Writing the parameters of the simulation allows the code to get the local values for Cp and Cf splitting between top and bottom side. ","category":"page"},{"location":"Tools/post_proc/","page":"Post Processing","title":"Post Processing","text":"cp_top, cp_bottom = extract_Cp(nodes, Ph; u0=u0, rho=rho)\nfriction_top, friction_bottom = extract_Cf(nodes, Friction, μ; u0=u0, rho=rho)\n\nCL,CD = compute_CL_CD(nodes, cp_top, cp_bottom,\nfriction_top, friction_bottom; chord=1.0)","category":"page"},{"location":"Tools/post_proc/","page":"Post Processing","title":"Post Processing","text":"It is possible to plot the results. For example","category":"page"},{"location":"Tools/post_proc/","page":"Post Processing","title":"Post Processing","text":"using Plots\nplot(nodes.top.x, cp_top, label = \"VMS\", color = :red, linewidth = 1.5)\nplot!(nodes.bottom.x,cp_bottom, label = false, color = :red, linewidth = 1.5 )","category":"page"},{"location":"Tools/post_proc/#Advanced-Post-Processing","page":"Post Processing","title":"Advanced Post Processing","text":"","category":"section"},{"location":"Tools/post_proc/","page":"Post Processing","title":"Post Processing","text":"There are also more powerful API to extract velocity fluctuations, TKE and spectra.","category":"page"},{"location":"Tools/post_proc/#Time-Averaging","page":"Post Processing","title":"Time Averaging","text":"","category":"section"},{"location":"Tools/post_proc/","page":"Post Processing","title":"Post Processing","text":"In this example we compute the time-average of the velocity field in the volume \"topairfoil\". The user while creating the mesh has to add this tag to the volume to analyze","category":"page"},{"location":"Tools/post_proc/","page":"Post Processing","title":"Post Processing","text":"tagname=\"topairfoil\"\n\ntopairfoil_nodes = get_nodes(res_path; tagname=tagname)\n\nVel_avg3D = compute_time_average(res_path; tagname=tagname)\nVel_avg2D = compute_time_span_average(res_path,Vel_avg3D; tagname=tagname)","category":"page"},{"location":"Tools/post_proc/","page":"Post Processing","title":"Post Processing","text":"It is possible to extract one of the components of the average velocity","category":"page"},{"location":"Tools/post_proc/","page":"Post Processing","title":"Post Processing","text":"ux_avg = Vel_avg2D[:,1]\nuy_avg = Vel_avg2D[:,2]\nuz_avg = Vel_avg2D[:,3]","category":"page"},{"location":"Tools/post_proc/","page":"Post Processing","title":"Post Processing","text":"And to plot it on the plane 0.1","category":"page"},{"location":"Tools/post_proc/","page":"Post Processing","title":"Post Processing","text":"xgrid,ygrid,velocity_dense = compute_scatter_interp(res_path, ux_avg, 0.1)\n\nusing Plots\n\n#it can take a while\nscatter(xgrid,ygrid .+ 0.0028;\nzcolor=velocity_dense,markerstrokewidth=0, label=\"U_x average\")","category":"page"},{"location":"Tools/post_proc/#Fluctuations","page":"Post Processing","title":"Fluctuations","text":"","category":"section"},{"location":"Tools/post_proc/","page":"Post Processing","title":"Post Processing","text":"It is possible to create a proble aligned with the z axis in the point xc,yc and get the fluctuations of that line.","category":"page"},{"location":"Tools/post_proc/","page":"Post Processing","title":"Post Processing","text":"xc,yc= 0.5,0.1 #it has to be a point of the domain\nzprobe, Vel = read_fluctuations(res_path, [xc,yc]; offset=1_000,offend=5_000)","category":"page"},{"location":"Tools/post_proc/","page":"Post Processing","title":"Post Processing","text":"It is also possible to compute the Power Spectral Density (PSD)","category":"page"},{"location":"Tools/post_proc/","page":"Post Processing","title":"Post Processing","text":"dt = 0.001\nnt=size(Vel)[1]-1 #Number of time-steps\ntn = collect(0.0:dt:dt*nt)\nPSD,freqs = compute_PSD(Vel, tn)","category":"page"},{"location":"Tools/post_proc/","page":"Post Processing","title":"Post Processing","text":"Computing the TKE in the plane 0.1","category":"page"},{"location":"Tools/post_proc/","page":"Post Processing","title":"Post Processing","text":"tke_xy = compute_plane_tke(res_path; zp =0.1)","category":"page"},{"location":"Tools/post_proc/","page":"Post Processing","title":"Post Processing","text":"info: OutOfMemory() Error\nProcessing Large Amount of data can saturate all the RAM available on your system. Try changing machines or reducing the admount of data to process.","category":"page"},{"location":"Tools/blinit/#Boundary-Layer-Initialization","page":"Boundary Layer Initialization","title":"Boundary Layer Initialization","text":"","category":"section"},{"location":"Tools/blinit/","page":"Boundary Layer Initialization","title":"Boundary Layer Initialization","text":"In order to avoid instabilities and help the convergence of the numerical system this tecnique is adopted. It is based on the resolution of the p-poisson, [5]. The algorithm used to solve the non-linear p-Poisson, equation \\eqref{equ:ppoisson} equation resembles the Picard method.","category":"page"},{"location":"Tools/blinit/","page":"Boundary Layer Initialization","title":"Boundary Layer Initialization","text":"nabla cdot (nabla u_p^p-2 nabla u_p) = -1  xin Omega u_p = 0  xin Omega_D","category":"page"},{"location":"Tools/blinit/","page":"Boundary Layer Initialization","title":"Boundary Layer Initialization","text":"The idea is to compute the wall-normal distance, from the airfoil, for each point of the domain. Then setting a threshold based on the Reynolds number, the velocity in the area close to the airfoil follows a cubic function.","category":"page"},{"location":"Tools/blinit/","page":"Boundary Layer Initialization","title":"Boundary Layer Initialization","text":"(Image: Velocity initialization)","category":"page"},{"location":"Tools/blinit/#How-to-use-it","page":"Boundary Layer Initialization","title":"How to use it","text":"","category":"section"},{"location":"Tools/blinit/","page":"Boundary Layer Initialization","title":"Boundary Layer Initialization","text":"It is possible to initialize the airfoil simulation using the WallDistance module. It works only in serial and for 2D meshes but it is possible to initialize a 3D solution from a 2D results.","category":"page"},{"location":"Tools/blinit/","page":"Boundary Layer Initialization","title":"Boundary Layer Initialization","text":"using SegregatedVMSSolver\nusing SegregatedVMSSolver.WallDistance\n\n\nmesh_file = joinpath(@__DIR__, \"../../models\", \"DU89_2D_A1_M.msh\")\n\nD = 2\nu_in = 1.0\nRe = 500e3\nchord = 1.0\nwalltag = [\"airfoil\"]\n\ndf_start = get_initial_conditions(mesh_file, u_in, Re, walltag; D=D, chord=chord)","category":"page"},{"location":"Tools/blinit/","page":"Boundary Layer Initialization","title":"Boundary Layer Initialization","text":"This will create a Initial_Conditions.vtu which can be open in ParaView and BoundaryLayerInit.csv which can be used to restart the simulation. Only the velocity is initilized, not the pressure.","category":"page"},{"location":"Theory/SUPG_VMS_stab/#SUPG-and-VMS-Stabilization","page":"SUPG & VMS Stabilization","title":"SUPG and VMS Stabilization","text":"","category":"section"},{"location":"Theory/SUPG_VMS_stab/#Stabilized-Equations","page":"SUPG & VMS Stabilization","title":"Stabilized Equations","text":"","category":"section"},{"location":"Theory/SUPG_VMS_stab/","page":"SUPG & VMS Stabilization","title":"SUPG & VMS Stabilization","text":"Recalling the Galerkin Fromulation of the Navier-Stokes Equations:","category":"page"},{"location":"Theory/SUPG_VMS_stab/","page":"SUPG & VMS Stabilization","title":"SUPG & VMS Stabilization","text":"B^G  =   int_Omega left ( R_m cdot v right )dOmega + int_Omega left ( R_c cdot q right )dOmega","category":"page"},{"location":"Theory/SUPG_VMS_stab/","page":"SUPG & VMS Stabilization","title":"SUPG & VMS Stabilization","text":"Using same-order interpolation elements for velocity and pressure (e.g. Q1/Q1)","category":"page"},{"location":"Theory/SUPG_VMS_stab/","page":"SUPG & VMS Stabilization","title":"SUPG & VMS Stabilization","text":"The SUPG (Streamline Upwind Petrov Galerkin) stabilzation term are:","category":"page"},{"location":"Theory/SUPG_VMS_stab/","page":"SUPG & VMS Stabilization","title":"SUPG & VMS Stabilization","text":"B^SUPG  =     int_Omegabigg (tau_m(u cdotnabla v +nabla q)cdot R_m bigg )dOmega+ int_Omega tau_c (nabla cdot v)R_c dOmega","category":"page"},{"location":"Theory/SUPG_VMS_stab/","page":"SUPG & VMS Stabilization","title":"SUPG & VMS Stabilization","text":"The extra terms added by the VMS:","category":"page"},{"location":"Theory/SUPG_VMS_stab/","page":"SUPG & VMS Stabilization","title":"SUPG & VMS Stabilization","text":"B^VMS1  = int_Omega (ucdotnabla v)cdot(tau_m R_m) dOmega","category":"page"},{"location":"Theory/SUPG_VMS_stab/","page":"SUPG & VMS Stabilization","title":"SUPG & VMS Stabilization","text":"B^VMS2  = -int_Omega bigg (nabla vcdot(tau_m R_m otimes tau_m R_m) bigg )dOmega","category":"page"},{"location":"Theory/SUPG_VMS_stab/#Stabilization-Parameters","page":"SUPG & VMS Stabilization","title":"Stabilization Parameters","text":"","category":"section"},{"location":"Theory/SUPG_VMS_stab/","page":"SUPG & VMS Stabilization","title":"SUPG & VMS Stabilization","text":"The stabilization parameters \\tau_m and \\tau_c can be computed accordingly to a ScalarFormulation() or a TensorFormulation() and it can be specified in the code.","category":"page"},{"location":"Theory/SUPG_VMS_stab/#ScalarFormulation","page":"SUPG & VMS Stabilization","title":"ScalarFormulation","text":"","category":"section"},{"location":"Theory/SUPG_VMS_stab/","page":"SUPG & VMS Stabilization","title":"SUPG & VMS Stabilization","text":"Typically used with the SUPG. ","category":"page"},{"location":"Theory/SUPG_VMS_stab/","page":"SUPG & VMS Stabilization","title":"SUPG & VMS Stabilization","text":"tau_m = bigg(dfrac2uh_e +dfrac4nuh_e^2 +dfrac2dt bigg)^-1","category":"page"},{"location":"Theory/SUPG_VMS_stab/","page":"SUPG & VMS Stabilization","title":"SUPG & VMS Stabilization","text":"tau_c = (ucdot u)tau_m","category":"page"},{"location":"Theory/SUPG_VMS_stab/","page":"SUPG & VMS Stabilization","title":"SUPG & VMS Stabilization","text":"Where h is the element dimension. It is the square root of the area for 2D case, and the cubic root of the volume for 3D case.","category":"page"},{"location":"Theory/SUPG_VMS_stab/#TensorFormulation","page":"SUPG & VMS Stabilization","title":"TensorFormulation","text":"","category":"section"},{"location":"Theory/SUPG_VMS_stab/","page":"SUPG & VMS Stabilization","title":"SUPG & VMS Stabilization","text":"Typically used with the VMS. ","category":"page"},{"location":"Theory/SUPG_VMS_stab/","page":"SUPG & VMS Stabilization","title":"SUPG & VMS Stabilization","text":"tau_m =bigg( dfrac4Delta t^2 + ucdot GGu + C_I nu^2 GG bigg)^-12","category":"page"},{"location":"Theory/SUPG_VMS_stab/","page":"SUPG & VMS Stabilization","title":"SUPG & VMS Stabilization","text":"tau_c = (tau_c gcdot g)^-1","category":"page"},{"location":"Theory/SUPG_VMS_stab/","page":"SUPG & VMS Stabilization","title":"SUPG & VMS Stabilization","text":"Where G is the inverse of the gradient of the map cell.","category":"page"},{"location":"create_case/#Create-Your-Own-Case","page":"Create your Own Case","title":"Create Your Own Case","text":"","category":"section"},{"location":"create_case/","page":"Create your Own Case","title":"Create your Own Case","text":"The code itself allows the user to create custom cases for their needs.","category":"page"},{"location":"create_case/#Box-case","page":"Create your Own Case","title":"Box case","text":"","category":"section"},{"location":"create_case/","page":"Create your Own Case","title":"Create your Own Case","text":"using SyntheticEddyMethod\nusing SegregatedVMSSolver.ParametersDef\nusing SegregatedVMSSolver.SolverOptions\nusing SegregatedVMSSolver.CreateProblem\n\n\ncreate_new_case(:Box)\nend ","category":"page"},{"location":"create_case/","page":"Create your Own Case","title":"Create your Own Case","text":"The user can create specific boundary conditions for the case. The function requires 3 outputs.","category":"page"},{"location":"create_case/","page":"Create your Own Case","title":"Create your Own Case","text":"function SegregatedVMSSolver.CreateProblem.boundary_velocities(simcase::Box)   \n    \n    \n    u_inlet(x,t) = VectorValue(1.0,0.0)\n    u_inlet(t::Real) = x -> u_inlet(x,t)\n\n    u_wall(x,t) = VectorValue(0.0,0.0)\n    u_wall(t::Real) = x -> u_wall(x,t)\n\n    pressure_outlet(x,t) = 0.0\n    pressure_outlet(t::Real) = x -> pressure_outlet(x,t)\n    \n    return u_inlet,u_outlet,pressure_outlet\nend","category":"page"},{"location":"create_case/","page":"Create your Own Case","title":"Create your Own Case","text":"And then, associating the function to the boundaries","category":"page"},{"location":"create_case/","page":"Create your Own Case","title":"Create your Own Case","text":"function SegregatedVMSSolver.CreateProblem.create_boundary_conditions(simcase::Box, u_inlet,u_outlet,pressure_outlet) \n        u_diri_tags=[\"inlet\",\"limits\"]\n        u_diri_values = [u_inlet,u_outlet]\n        p_diri_tags=[\"outlet\"]\n        p_diri_values = [pressure_outlet]\n        return u_diri_tags,u_diri_values,p_diri_tags,p_diri_values\nend ","category":"page"},{"location":"Cases/airfoil/#Airfoil","page":"Airfoil","title":"Airfoil","text":"","category":"section"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"(Image: LSB-s7003)","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"It is one of the most complex and interesting case. The user has to create a proper mesh in gmsh setting the following physical boundaries:","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"inlet for the inlet\noutlet for the outlet\nairfoil for the airfoil walls\nlimits for the top and bottom boundaries","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"info: .geo file\nIn the folder models/ is possible to find some .msh file created using gmsh both for 3D and 2D simulations.  In the folder models/geo are available some .geo that can be open in gmsh. Different parameters can be modified: angle of attack, domain dimension, mesh divisions.","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"The velocity at the inlet is increased from 0.0 arriving to the target value u_in at t_endramp. This increase the numeric stability. If t_endramp = t0 the velocity at the inlet will be immediately u_in. For numeric stability is better to keep u_in = [1.0,0.0,0.0], then fix the Reynolds and so the viscosity will be automatically computed as: ν = 1/Reynolds","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"The pressure is set 0.0 at the outlet section. The velocity on the limits is set equal to the one at inlet.","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"3D LES are heavy and it is possible to experience divergence issues. It is suggested to use one of the two initialization techniques: Velocity ramping or Boundary layer initialization. For visualize the results, please refer to the section. ","category":"page"},{"location":"Cases/airfoil/#NACA0012","page":"Airfoil","title":"NACA0012","text":"","category":"section"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"A common validation test case is to analyze the NACA0012 airfoil and compare the pressure distribution with experimental results. This is a simple 2D simulation at high Reynolds number 3e6. For run this case it is suggested to have hypre installed to use a more powerful preconditioner for the resolution. It has been tested on 16 CORES and requires approximately 35 hours.","category":"page"},{"location":"Cases/airfoil/#Simulation-File","page":"Airfoil","title":"Simulation File","text":"","category":"section"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"using PartitionedArrays\nusing SegregatedVMSSolver\nusing SegregatedVMSSolver.ParametersDef\nusing SegregatedVMSSolver.SolverOptions","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"Set the physical parameters of the simulation","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"t0 =0.0\ndt = 0.00025\ntF = 15.0\n\nRe = 3_000_000\nD = 2\nrank_partition = (16,1,1)\nmesh_file = joinpath(@__DIR__, \"NACA 0012_2D_A10.msh\")","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"Setting the parameters of the simulation","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"sprob = StabilizedProblem(VMS(1))\ntimep = TimeParameters(t0=t0,dt=dt,tF=tF,t_endramp=2.0)\n\nphysicalp = PhysicalParameters(Re=Re)\nsolverp = SolverParameters(M=25,Number_Skip_Expansion=1e6, petsc_options = petsc_options_cstm(), matrix_freq_update=1)\nexportp = ExportParameters(printinitial=true,printmodel=true,name_tags=[\"airfoil\"], fieldexport=[[\"ph\",\"friction\"]])\n\n\nmeshp= MeshParameters(rank_partition,D,mesh_file)\n\nsimparams = SimulationParameters(timep,physicalp,solverp,exportp)\n\nAirfoilCase = Airfoil(meshp,simparams,sprob)\n","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"Solve in Sequential - on 1 processor not using MPI, useful for debug.","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":" SegregatedVMSSolver.solve(AirfoilCase,with_debug)","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"Solve in MPI - for HPC computing","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":" SegregatedVMSSolver.solve(AirfoilCase,with_mpi)","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"Then in bash give the command. Check the MPI section for more details","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":" mpiexecjl -n 4 julia --project=. run_mysimulation.jl","category":"page"},{"location":"Cases/airfoil/#Results","page":"Airfoil","title":"Results","text":"","category":"section"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"The results can be post-processed using the following script. The first 10000 time-steps are skipped to avoid the initial transient.","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"\nusing Pkg\nPkg.activate(\"../.\")\nusing SegregatedVMSSolver\nusing SegregatedVMSSolver.ReadAirfoilResults\nusing Plots, LaTeXStrings, KissSmoothing\nusing CSV, DataFrames\nusing JLD2\n\nCase = \"NACA0012\"\nα = 10.0\n\n\nres_path = joinpath(@__DIR__, \"$(Case)_A$(Int64(α))\", \"Results/\") \n\n\nRe = 3_000_000\n\nder_slope= -1.0\n\n\nu0 = 1.0\nc = 1.0\nrho = 1.0\nμ = u0*c*rho/Re\n\n\n\nnodes, normals = get_geometry_info(res_path;α=α, der_slope= der_slope)\n\nPh = time_space_average_field(res_path, \"ph\", nodes; offset=10_000)\n\ncp_top, cp_bottom = extract_Cp(nodes, Ph; u0=u0, rho=rho)\n\n\nplot(nodes.top.x ./ cosd(α), cp_top, label = \"2D - VMS\", color = :red, linewidth = 1.5)\nplot!(nodes.bottom.x./ cosd(α), cp_bottom, label = false, color = :red, linewidth = 1.5)\nyflip!()\nplot!(xlabel=\"x/c\", ylabel=\"Cp\", legend=:top)","category":"page"},{"location":"Cases/airfoil/","page":"Airfoil","title":"Airfoil","text":"The pressure distribution results are compared with the experiments reported in [4] (Image: NACA0012_CP)","category":"page"},{"location":"Cases/cylinder/#Cylinder","page":"Cylinder","title":"Cylinder","text":"","category":"section"},{"location":"Cases/cylinder/","page":"Cylinder","title":"Cylinder","text":"(Image: Cyx)","category":"page"},{"location":"Cases/cylinder/","page":"Cylinder","title":"Cylinder","text":"The Cylinder case can be used to see how meshes created in  gmsh are manged and to obtain the vortex shedding phenomena. The user has to create a proper mesh in gmsh setting the following physical boundaries:","category":"page"},{"location":"Cases/cylinder/","page":"Cylinder","title":"Cylinder","text":"inlet for the inlet\noutlet for the outlet\ncylinder for the cylinder walls\nlimits for the top and bottom boundaries","category":"page"},{"location":"Cases/cylinder/","page":"Cylinder","title":"Cylinder","text":"using PartitionedArrays\nusing SegregatedVMSSolver\nusing SegregatedVMSSolver.ParametersDef\nusing SegregatedVMSSolver.SolverOptions\n\nt0 =0.0\ndt = 0.1\ntF = 0.5\n\nRe = 100\nD = 2\nrank_partition = (2,2)\ncylinder_mesh_file = joinpath(@__DIR__,\"..\", \"assets\", \"Cylinder_2D.msh\")\n\n\nsprob = StabilizedProblem(SUPG(1))\ntimep = TimeParameters(t0,dt,tF)\n\nphysicalp = PhysicalParameters(Re=Re)\nsolverp = SolverParameters()\nexportp = ExportParameters(printinitial=false,printmodel=false)\n\n\nmeshp= MeshParameters(rank_partition,D,cylinder_mesh_file)\nsimparams = SimulationParameters(timep,physicalp,solverp,exportp)\n\n\nmcase = Cylinder(meshp,simparams,sprob)\n\nSegregatedVMSSolver.solve(mcase,backend)","category":"page"},{"location":"Theory/NS_inc/#The-Incompressible-Unsteady-Navier-Stokes-Equations","page":"Incompressible Navier Stokes","title":"The Incompressible Unsteady Navier-Stokes Equations","text":"","category":"section"},{"location":"Theory/NS_inc/","page":"Incompressible Navier Stokes","title":"Incompressible Navier Stokes","text":"The package ´SegregatedVMSSolver´ solves the unsteady incompressible Navier-Stokes. The conservation equations takes the following form:","category":"page"},{"location":"Theory/NS_inc/","page":"Incompressible Navier Stokes","title":"Incompressible Navier Stokes","text":"Mass Conservation","category":"page"},{"location":"Theory/NS_inc/","page":"Incompressible Navier Stokes","title":"Incompressible Navier Stokes","text":"R_c = nablacdot(u)=0","category":"page"},{"location":"Theory/NS_inc/","page":"Incompressible Navier Stokes","title":"Incompressible Navier Stokes","text":"Momentum Conservation","category":"page"},{"location":"Theory/NS_inc/","page":"Incompressible Navier Stokes","title":"Incompressible Navier Stokes","text":"R_m = fracpartial upartial t + ucdotnabla(u) +nabla(p) -nu Delta(u) = f","category":"page"},{"location":"Theory/NS_inc/","page":"Incompressible Navier Stokes","title":"Incompressible Navier Stokes","text":"Where:","category":"page"},{"location":"Theory/NS_inc/","page":"Incompressible Navier Stokes","title":"Incompressible Navier Stokes","text":"u is the velocity field\np is the pressure (normalized with density, assumed to be unitary)\nnu is the kinematic viscosity of the fluid\nf is the momentum source term ","category":"page"},{"location":"#SegregatedVMSSolver.jl","page":"Introduction","title":"SegregatedVMSSolver.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"SegregatedVMSSolver.jl for solving incompressible Navier-Stokes using stabilized Finite Element Method, in specific Streamline-Upwind Petrov-Galerkin (SUPG) and Variational MultiScale method (VMS)","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The package solves the incompressible Navier-Stokes equations in the Finite Element Framework using SUPG and VMS method. VMS has been originally introduced by [1]. In specific, a linearized and segregated version of the SUPG (following the steps illustrated by [2]) and VMS is solved. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The methods belong to the Large Eddy Simulation (LES) family. The package can solve the Taylor Green Vortices, Lid Driven Cavity Flow (only 2D), Cylinder vortex shedding and and general Airfoils (2D and 3D). ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"It works fully in parallel (tested up to 80-CORES). It is specialized for the resolution of flow over airfoils, testing the capability of detecting the Laminar Separation Bubble. It is equipped with some utilities modules for reading the output files and creating proper initial conditions.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The package is registered, so you can install it as:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(SegregatedVMSSolver)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"or from the REPL just press ].","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(@1.8) pkg> add SegregatedVMSSolver","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You can use the most recent release installing it as:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(url=\"https://github.com/carlodev/SegregatedVMSSolver.jl\")","category":"page"},{"location":"#Suggested-software-to-install","page":"Introduction","title":"Suggested software to install","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"For a complete and smooth experience is suggested to install the free software ParaView which allows to graphically visualize the results and open .vtu and .pvtu files. For creating mesh and physical boundary conditions is suggested to install the free software gmsh.","category":"page"},{"location":"#Features","page":"Introduction","title":"Features","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Implementation of SUPG and VMS formulation for same order elements for velocity and pressure\nSolve 3D airfoils geometries, time-dependend, fully parallelized code\nUsing custom Meshes created with gmsh. For airfoils the package AirfoilGmsh.jl has been developed for speeding up the process\nSolve 2D and 3D cases\nPossibility of choosing the backend thanks to PartitionedArrays.jl. It can be run in the REPL for debugging or in MPI","category":"page"},{"location":"#Packages","page":"Introduction","title":"Packages","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"It relies on the  Gridap ecosystem. It is also completely written in Julia and allows parallelization. The MPI and PartititionedArrays are also at the basis of the parallelization.","category":"page"}]
}
