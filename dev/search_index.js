var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"run/#Package-usage","page":"Running Simulation","title":"Package usage","text":"","category":"section"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":"The package allows the user to set a wide variety of options. Problem Settings:","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":":N = number of divisions for each dimension.\n:D = dimension. It can be 2 or 3.\n:order = order of the elements. At the moment just the order 1 is tested.\n:case it can be \"TaylorGreen\", \"LidDriven\", \"Cylinder\", \"Channel\", \"Airfoil\".\n:u_in the inlet velocity for \"Airfoil\" and \"Cylinder\", or the lid velocity for \"LidDriven\n:c chord length in the \"Airfoil\" case, or dimension of lid for \"LidDriven\". It is used to compute the viscosity :ν from the Reynolds and velocity\n:Re Reynolds number. \n:ν kinematic viscosity. It can be overwritten in order to satisfy the Reynolds, in this case a warning informs the user.\n:ρ density. It used just to compute the force. The advice is to keep it 1.0 and just set the Reynolds.","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":"<!– - :body_force is non-zero generally just for the case of a periodic channel.","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":":periodic used only in the \"Channel\" case. It can be set true or false –>","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":"Time settings","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":":t0 starting time.\n:dt time step length.\n:tF end time.\n:t_endramp for high reynolds cases, like airfoils and lid driven, for improving numeric stability the inlet velocity (or the lid velocity) are increased from 0 up the desired value in the time between :t0 and :tendramp. If :t0 = :tendramp there is no ramping.","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":"Ode Settings","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":"θ parameter required for time integration.  θ = 05 allows to have 2nd order accuracy on velocity. For the pressure is alwys used a fully implicit method.","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":"Numeric Settings","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":":method can be :SUPG or :VMS\n:Cᵢ is a vector containing stabilization coefficients used for the :VMS. The suggested values are [4,36], [3]\n:options the settings for the petsc solver. The function petsc_options can be used.","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":"Print Settings","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":":printmodel can be true or false. If true mesh is saved as a .pvtu file.\n:printinitial can be true or false. If true saves the flowfield at t0. It is useful when restarting from a previous solution.\n:benchmark  can be true or false. If true it does not print the solution, and it gives the time needed for computing the iteration form the 2nd till the end. The first iteration is not taken into account for computing the time because of precompilation.","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":"Mesh Settings","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":":mesh_file is a string with the name of the .msh that can be read. By default it points to the folder /models of the package.","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":"Partitioning Settings","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":":rank_partition tuple which set the number of division on each axes to split the geometry to the processors.  For non cartesian problems it does not matter how the cores are split into the dimensions as long as prod(rank_partition) is equal to the MPI ranks.\nbackend can be with_debug() (can be run in the REPL) or with_mpi(). ","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":"Restarting Settings","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":":restart can be true or false. If false the initial conditions are computed internally using :u_in or analytical solution (\"TaylorGreen\"). \n:restart_file is used only if :restartis true. It is a .csv file created from ParaView using the SpreadSheet. It has the list of fo velocity and pressure in each node. It is better to run clean grid in Paraview before for get rid of duplicate points.","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":"<!– Turbulence Settings For creating turbulence the package SyntheticEddyMethod is used.","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":":start_condition for the channel, still work in progress.\n:TI Turbulence Intensity for the inlet. If it is set 0.0 it means no turbulence.\n:Vbox => turbulence_box() contains the information of the virtual box where the Eddies are created. More details in the documentation of SyntheticEddyMethod. The parameters can be adjsuted in Turbulence_Settings.jl file. \n:Re_filename it contains the string of the Reynolds stress file, which is a .xlsx file. If you want to create turbulence from the :TI parameters set it to \"none\" –>","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":"using SegregatedVMSSolver\nusing Parameters,PartitionedArrays\n\n  \n   params = Dict(\n         :N => 32,\n         :D => 2, #Dimension\n         :order => 1, \n         :t0 => 0.0,\n         :dt => 0.25,\n         :tF => 1.0,\n         :case => \"TaylorGreen\",\n         :θ => 0.5,\n         :u_in=> 1.0,\n        \n         :backend => with_debug,  #or with_mpi()\n         :rank_partition=>(2,2),\n         :ν => 0.001,\n         :petsc_options => petsc_options_default(),\n         :method=>:VMS,\n         :Cᵢ => [4, 36],\n    \n         :t_endramp=>0.0,\n         :mesh_file => \" \",\n         :Re=> 1000,\n         \n         :c=> 1.0,\n \n   )\n   \n   \n SegregatedVMSSolver.main(params) \n","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":"The example above run in the REPL emulating a parallel run over 4 processors (you can see it by the options rank_partition). ","category":"page"},{"location":"run/","page":"Running Simulation","title":"Running Simulation","text":"info: numeric info\nChanging the backend to with_mpi() allows it to run in MPI. ","category":"page"},{"location":"api_info/#Index","page":"API information","title":"Index","text":"","category":"section"},{"location":"api_info/#Initialize-Parameters","page":"API information","title":"Initialize Parameters","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"init_params\nverifykey","category":"page"},{"location":"api_info/#SegregatedVMSSolver.init_params","page":"API information","title":"SegregatedVMSSolver.init_params","text":"init_params(params::Dict{Symbol,Any})\n\nIt initialize the parametes of the simulations. Default values are added if not specified by the user. In case of a restarting simulation it reads the file and create a initial_rescale_factor<1 for CFL ramping initialization.\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.verifykey","page":"API information","title":"SegregatedVMSSolver.verifykey","text":"verifykey(params::Dict{Symbol,Any},keyname; val = false)\n\nIt check if the dictionary params has the entry keyname. If not it adds the new entry with the value val. It is used to add default values\n\n\n\n\n\n","category":"function"},{"location":"api_info/#Commons-Procedures","page":"API information","title":"Commons Procedures","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"print_model\ncreation_fe_spaces\ncreate_initial_conditions\ncreate_PETSc_setup\nsolve_case","category":"page"},{"location":"api_info/#SegregatedVMSSolver.print_model","page":"API information","title":"SegregatedVMSSolver.print_model","text":"print_model(params::Dict{Symbol, Any})\n\nIt prints the model mesh\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.creation_fe_spaces","page":"API information","title":"SegregatedVMSSolver.creation_fe_spaces","text":"creationfespaces(params::Dict{Symbol,Any}, udiritags, udirivalues, pdiritags, pdirivalues)\n\nIt creates the finite elements spaces accordingly to the previously generated dirichelet tags\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.create_initial_conditions","page":"API information","title":"SegregatedVMSSolver.create_initial_conditions","text":"createinitialconditions(params::Dict{Symbol,Any})\n\nIt creates the initial conditions for velocity and pressure. If restart is true then the velocity and the pressure field are interpoled on the specified DataFrame.  \n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.create_PETSc_setup","page":"API information","title":"SegregatedVMSSolver.create_PETSc_setup","text":"createPETScsetup(M::AbstractMatrix,ksp_setup::Function)\n\nWrapper for creating PETSc symbolic and numeric setup for GridapPETSc  \n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.solve_case","page":"API information","title":"SegregatedVMSSolver.solve_case","text":"solve_case(params::Dict{Symbol,Any})\n\nIt solves iteratively the velocity and pressure system.\n\n\n\n\n\n","category":"function"},{"location":"api_info/#AddNewTags","page":"API information","title":"AddNewTags","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"create_new_tag!\nadd_new_tag!\nadd_centre_tag!","category":"page"},{"location":"api_info/#SegregatedVMSSolver.create_new_tag!","page":"API information","title":"SegregatedVMSSolver.create_new_tag!","text":"create_new_tag!(model::GridapDistributed.DistributedDiscreteModel, tagname::String, is_tag::Function)\n\nIt creates the centre tag at the tag_coordinate (Point); if mesh extremely fine the tolrances have to be smaller (unlikely)\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.add_new_tag!","page":"API information","title":"SegregatedVMSSolver.add_new_tag!","text":"add_new_tag!(model, tag_coordinate::Point, tagname::String)\n\nIt add a new tag named tagname at the specified tag_coordinates    \n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.add_centre_tag!","page":"API information","title":"SegregatedVMSSolver.add_centre_tag!","text":"add_centre_tag!(model, tag_coordinate::Point)\n\nIt creates the centre tag at the tag_coordinate (Point); if mesh extremely fine the tolrances have to be smaller (unlikely)\n\n\n\n\n\n","category":"function"},{"location":"api_info/#Stabilization-Parameters","page":"API information","title":"Stabilization Parameters","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"h_param\nG_params\ncompute_d\ncompute_G\ncompute_GG\ncompute_gg","category":"page"},{"location":"api_info/#SegregatedVMSSolver.h_param","page":"API information","title":"SegregatedVMSSolver.h_param","text":"h_param(Ω::Triangulation, D::Int64)\n\nFor a given triangulation Ω it computes the cell size Area^12 D=2 Volume^13 D=3\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.G_params","page":"API information","title":"SegregatedVMSSolver.G_params","text":"G_params(Ω::Triangulation, params)\n\nCompute the tensor G and the values GG and gg according to the VMS formulation proposed by [4] \n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.compute_d","page":"API information","title":"SegregatedVMSSolver.compute_d","text":"compute_d(trian::Gridap.Geometry.BodyFittedTriangulation, params) #trian == Ω\n\nThe inverse of the cell-map-field. It is evaluted in the middle of the refernce domain.\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.compute_G","page":"API information","title":"SegregatedVMSSolver.compute_G","text":"compute_G(trian::Gridap.Geometry.BodyFittedTriangulation, params)\n\nCompute G (AbstractArray of TensorValues)\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.compute_GG","page":"API information","title":"SegregatedVMSSolver.compute_GG","text":"compute_GG(trian::Gridap.Geometry.BodyFittedTriangulation, params)\n\nCompute GG \n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.compute_gg","page":"API information","title":"SegregatedVMSSolver.compute_gg","text":"compute_GG(trian::Gridap.Geometry.BodyFittedTriangulation, params)\n\nCompute gg \n\n\n\n\n\n","category":"function"},{"location":"api_info/#Linear-Utilities","page":"API information","title":"Linear Utilities","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"create_ũ_vector\nupdate_ũ_vector!\nupdate_ũ","category":"page"},{"location":"api_info/#SegregatedVMSSolver.create_ũ_vector","page":"API information","title":"SegregatedVMSSolver.create_ũ_vector","text":"createũvector(zfv1::AbstractVector)\n\nIt allocates the vector to keep in memory the velocity field up to previous 4 time steps\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.update_ũ_vector!","page":"API information","title":"SegregatedVMSSolver.update_ũ_vector!","text":"updateũvector!(ũvec::Vector, uhnew::AbstractVector)\n\nIt updates the vector which stores the values of velocity at previous time steps.\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.update_ũ","page":"API information","title":"SegregatedVMSSolver.update_ũ","text":"updateũ(ũvec::Vector)\n\nIt uses the Taylor expansion proposed by [5]\n\n\n\n\n\n","category":"function"},{"location":"api_info/#Stabilized-Equations","page":"API information","title":"Stabilized Equations","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"cconv\nsegregated_equations_SUPG!\nsegregated_equations_VMS!","category":"page"},{"location":"api_info/#SegregatedVMSSolver.cconv","page":"API information","title":"SegregatedVMSSolver.cconv","text":"cconv(uadv, ∇u) \n\nWrapper for the convective term   u(nabla u)  \n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.segregated_equations_SUPG!","page":"API information","title":"SegregatedVMSSolver.segregated_equations_SUPG!","text":"segregatedequationsSUPG!(u_adv, params)\n\nIt provides the SUPG segregated and linearized equations following the model proposed by [2]\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.segregated_equations_VMS!","page":"API information","title":"SegregatedVMSSolver.segregated_equations_VMS!","text":"segregatedequationsSUPG!(u_adv, params)\n\nIt provides the VMS segregated and linearized equations \n\n\n\n\n\n","category":"function"},{"location":"api_info/#SolversOptions","page":"API information","title":"SolversOptions","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"petsc_options","category":"page"},{"location":"api_info/#SegregatedVMSSolver.petsc_options","page":"API information","title":"SegregatedVMSSolver.petsc_options","text":"petscoptions(; velksp=\"gmres\", velpc=\"gamg\", presksp = \"cg\", pres_pc = \"gamg\") It provides the command-line for GridapPETSc to solve the segregated linear systems\n\n\n\n\n\n","category":"function"},{"location":"api_info/#MatrixCreation","page":"API information","title":"MatrixCreation","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"allocate_Mat_inv_ML\ninv_lump_vel_mass!\ninitialize_vectors\nmatrices_and_vectors ","category":"page"},{"location":"api_info/#SegregatedVMSSolver.allocate_Mat_inv_ML","page":"API information","title":"SegregatedVMSSolver.allocate_Mat_inv_ML","text":"allocateMatinvML(MatML::PSparseMatrix) \n\nIt allocates a zero vector where to store the inverse of the lumped matrix\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.inv_lump_vel_mass!","page":"API information","title":"SegregatedVMSSolver.inv_lump_vel_mass!","text":"invlumpvelmass!(MatinvML::PVector,MatML::PSparseMatrix)\n\nIt computes the lumped matrix, takes the inverse of the diagonal elements.\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.initialize_vectors","page":"API information","title":"SegregatedVMSSolver.initialize_vectors","text":"initialize_vectors(matrices::Tuple,uh0,ph0)\n\nIt initializes vectors where velocity, pressure, acceleration and all the increments will be stored.\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.matrices_and_vectors","page":"API information","title":"SegregatedVMSSolver.matrices_and_vectors","text":"matricesandvectors(trials, tests, t::Real, u_adv, params; method=:VMS)\n\nIt updates matrices and vectors\n\n\n\n\n\n","category":"function"},{"location":"api_info/#Restart","page":"API information","title":"Restart","text":"","category":"section"},{"location":"api_info/","page":"API information","title":"API information","text":"find_idx\nuh_restart\nph_restart\nrestart_uh_field\nrestart_ph_field","category":"page"},{"location":"api_info/#SegregatedVMSSolver.find_idx","page":"API information","title":"SegregatedVMSSolver.find_idx","text":"find_idx(p::VectorValue{3, Float64}, params)\n\nFor a given point p it search on the restart_file provided by the user the closer node and provides the index of such node.\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.uh_restart","page":"API information","title":"SegregatedVMSSolver.uh_restart","text":"uh_restart(p, params::Dict{Symbol, Any})\n\nFor a given point p it calles find_idx which provide the line of the csv file corresponding to that point. Then, it calles uh which provide the VectorValue of the velocity at that point.\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.ph_restart","page":"API information","title":"SegregatedVMSSolver.ph_restart","text":"ph_restart(p, params::Dict{Symbol, Any})\n\nFor a given point p it calles find_idx which provide the line of the csv file corresponding to that point. Then, it calles ph which provide the scalar pressure value at that point.\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.restart_uh_field","page":"API information","title":"SegregatedVMSSolver.restart_uh_field","text":"restart_uh_field(params::Dict{Symbol, Any})\n\nIt provides a suitable function which gives for each point the specified velocity in restart_file. It is used as initial condition for restarting a simulation at a specific time step.\n\n\n\n\n\n","category":"function"},{"location":"api_info/#SegregatedVMSSolver.restart_ph_field","page":"API information","title":"SegregatedVMSSolver.restart_ph_field","text":"restart_ph_field(params::Dict{Symbol, Any})\n\nIt provides a suitable function which gives for each point the specified pressure in restart_file. It is used as initial condition for restarting a simulation at a specific time step.\n\n\n\n\n\n","category":"function"},{"location":"#SegregatedVMSSolver.jl","page":"Introduction","title":"SegregatedVMSSolver.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"SegregatedVMSSolver.jl for solving incompressible Navier-Stokes using stabilized Finite Element Method, in specific Streamline-Upwind Petrov-Galerkin (SUPG) and Variational MultiScale method (VMS)","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The package solves the incompressible Navier-Stokes equations using SUPG and VMS method. VMS has been originally introduced by [1]. In specific, a linearized and segregated version of the SUPG (following the steps illustrated by [2]) and VMS is solved. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The methods belong to the Large Eddy Simulation (LES) family. The package can solve the Taylor Green Vortices (only 2D), Lid Driven Cavity Flow (only 2D), Cylinder vortex shedding (only 2D), and general Airfoils (2D and 3D). ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"It works fully in parallel (tested up to 80-CORES). It is specialized for the resolution of flow over airfoils, testing the capability of detecting the Laminar Separation Bubble. It is equipped with some utilities modules for reading the output files and creating proper initial conditions.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The package is registered, so you can install it as:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(SegregatedVMSSolver)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"or from the REPL just press ].","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(@1.8) pkg> add SegregatedVMSSolver","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You can use the most recent release installing it as:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(url=\"https://github.com/carlodev/SegregatedVMSSolver.jl\")","category":"page"},{"location":"#Suggested-software-to-install","page":"Introduction","title":"Suggested software to install","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"For a complete and smooth experience is suggested to install the free software ParaView which allows to graphically visualize the results and open .vtu and .pvtu files. For creating mesh and physical boundary conditions is suggested to install the free software gmsh.","category":"page"},{"location":"#Features","page":"Introduction","title":"Features","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Implementation of SUPG and VMS formulation for same order elements for velocity and pressure\nSolve 3D airfoils geometries, time-dependend, fully parallelized code\nUsing custom Meshes created with gmsh. For airfoils the package AirfoilGmsh.jl has been developed for speeding up the process\nSolve 2D and 3D cases\nPossibility of choosing the backend thanks to PartitionedArrays.jl. It can be run in the REPL for debugging or in MPI","category":"page"}]
}
